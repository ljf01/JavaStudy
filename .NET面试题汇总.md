## .NET面试题汇总系列(一)：基础语法
1. 字符串中string str=null和string str=""和string str=string.Empty的区别  
string.Empty相当于“”,Empty是一个静态只读的字段。 string str="" ,初始化对象，并分配一个空字符串的内存空间 string str=null,初始化对象，不会分配内存空间

2. byte b = 'a'; byte c = 1; byte d = 'ab'; byte e = '啊'; byte g = 256; 这些变量有些错误是错再哪里?  
本题考查的是数据类型能承载数据的大小。
1byte =8bit，1个汉字=2个byte，1个英文=1个byte=8bit
所以bc是对的，deg是错的。'a'是char类型，a错误
java byte取值范围是-128~127, 而C#里一个byte是0~255
3. string和StringBuilder的区别,两者性能的比较  
都是引用类型，分配在堆上
StringBuilder默认容量是16，可以允许扩充它所封装的字符串中字符的数量.每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。
对于简单的字符串连接操作，在性能上stringbuilder不一定总是优于strin因为stringbulider对象的创建也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder的使用。从最后分析可以看出如果是相对较少的字符串拼接根本看不出太大差别。
Stringbulider的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分配操作，是不妥的实现方法。 参考链接：https://www.cnblogs.com/haofuqi/p/4826262.html
4. 什么是扩展方法？
一句话解释，扩展方法使你能够向现有类型“添加”方法，无需修改类型
条件：按扩展方法必须满足的条件，1.必须要静态类中的静态方法2.第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法
建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现
使用：不能通过类名调用，直接使用类型来调用
5. byte a =255;a+=5;a的值是多少？
byte的取值范围是-2的8次方至2的8次方-1，-256至258，a+=1时，a的值时0，a+=5时，a的值是0，所以a+=5时，值是4

6. 什么是装箱和拆箱？
装箱就是隐式地将一个值类型转换成引用类型，如：
int i=0;
Syste.Object obj=i;
拆箱就是将引用类型转换成值类型，如：
int i=0;
System.Object obj=i;
int j=(int)obj;（将obj拆箱）
7. 值类型和引用类型的区别
值类型变量是直接包含值。将一个值类型变量赋给另一个值类型变量，是复制包含的值，默认值是0。
引用类型变量的赋值只复制对对象的引用，而不复制对象本身，默认值是null
值类型有整形、浮点型、bool、枚举。
引用类型有class、delegate、Object、string
值类型存储在栈中，引用类型存储在堆中
8. new关键字的作用
运算符：创建对象实例
修饰符：在派生类定义一个重名的方法，隐藏掉基类方法
约束：泛型约束定义，约束可使用的泛型类型,如：
public class ItemFactory<T> where T : IComparable, new()
   {
   }
9. int?和int有什么区别
int？为可空类型，默认值可以是null
int默认值是0
int?是通过int装箱为引用类型实现
10. C#中的委托是什么？
一句话解释就是：将方法当作参数传入另一个方法的参数。 .net中有很多常见的委托如：Func 、Action 作用：提高方法的扩展性

11. 用最有效的方法算出2乘以8等于几？
位运算是最快，使用的是位运算 逻辑左位移<<。 方法是2<<3相当于0000 0000 0000 0010 （2的16位int二进制）左移三位就是 0000 0000 0001 0000（16的二进制）

12. const和readonly有什么区别？
都可以标识一个常量。主要有以下区别：

1. 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在静态构造方法（必须是静态构造方法，普通构造方法不行）里赋值。
2. 修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段
3. const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。
4. const默认是静态的；而readonly如果设置成静态需要显示声明
5. 修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。
13. 现有一个整数number，请写一个方法判断这个整数是否是2的N次方  
    4（100）、5（101）、8（1000）、16（10000）  
取模运算： 用number%2==0可以判断，但是这个有点低级  
位运算：（使用位运算逻辑并，两个位上的都为1才是1，其余都是0，判断是否等于0）  
4&3相当于100&011 ，结果是000等于0，所以4是2的n次方  
5&4相当于101&100，结果是100不等于0，所以5不是2的n次方  
如果要问如果是2的N次方，这个N是多少？这该怎么算？  
    ```C#
    private static byte get(int n)
        {
            byte number = 1;
            while (n/2!=1)
            {
                n = n / 2;
                number += 1;
            }
            return number;
        }
    ```
14. CTS、CLS、CLR分别作何解释
CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。

CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。
CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。
CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。
15. 在.net中，配件的意思是？
程序集。（中间语言，源数据，资源，装配清单）

16. 分析下面代码，a、b的值是多少？
string strTmp = "a1某某某";
int a = System.Text.Encoding.Default.GetBytes(strTmp).Length;
int b = strTmp.Length;
分析：一个字母、数字占一个byte，一个中文占占两个byte，所以a=8,b=5

17. Strings = new String(“xyz”);创建了几个String Object?
两个对象，一个是“xyz”,一个是指向“xyz”的引用对象s。

18. 静态成员和非静态成员的区别
1.静态成员用statis修饰符声明，在类被实例化时创建，通过类进行访问
2.不带statis的变量时非静态变量，在对象被实例化时创建，通过对象进行访问，
3.静态方法里不能使用非静态成员，非静态方法可以使用静态成员
4.静态成员属于类，而不属于对象
19. c#可否对内存直接操作
C#在unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针，C#NET默认不运行带指针的，需要设置下，选择项目右键->属性->选择生成->“允许不安全代码”打勾->保存

20. short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
s1+1不能显式转换成short类型，可以修改为s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1正确

21. 什么是强类型，什么是弱类型？哪种更好些？为什么?
强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如javascript,vb,php等

22. using关键字的作用
1. 引用命名空间，也可using 别名
2. 释放资源，实现了IDisposiable的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源。
23. ref和out有什么区别
1. 都是按引用类型进行传递
2. 属性不是变量不能作为out、ref参数传递
3. ref参数必须初始化。out不需要初始化
4. 作用，当方法有多个返回值时，out非常有用
24. a.Equals(b)和a==b一样吗？
不一样，a==b仅仅表示a和b值相等，a.Equals(b)表示a与b一致

25. 下面这段代码求值
    ```C#
    class Class1
        {
            internal static int count = 0;
            static Class1()
            {
                count++;
            }
            public Class1()
            {
                count++;
            }
        }
        Class1 o1 = new Class1();
        Class1 o2 = new Class1();
      o1.count的值是多少？
    
    答案：3，静态 构造方法计算一次，两个实例化对象计算两次。
    ```

26. 关于构造函数说法正确的是哪个？
    1. 构造函数可以声明返回类型。  

    2.  构造函数不可以用private修饰  

    3.  构造函数必须与类名相同  
 
    4.  构造函数不能带参数  

    答案：3,构造函数必须与类名相同，可以传递多个传递，作用就是便于初始化对象成员，不能有任何返回类型  

27. Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?
Math.Round(11.5)=12  
Math.Round(-11.5)=-12  
28. &和&&的区别
* 相同点
  * &和&&都可作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，其结果才为true，否则，只要有一方为false，则结果为false。（ps：当要用到逻辑与的时候&是毫无意义，&本身就不是干这个的）

* 不同点
* if(loginUser!=null&&string.IsnullOrEmpty(loginUser.UserName))
  &&具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，对于上面的表达式，当loginUser为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。（ps：所以说当要用到逻辑与的时候&是毫无意义的）

* & 是用作位运算的。

* 总结
  * &是位运算，返回结果是int类型 &&是逻辑运算，返回结果是bool类型

29. i++和++i有什么区别？
    1. i++是先赋值，然后再自增；++i是先自增，后赋值。
    2. i=0，i++=0，++i=1； Console.WriteLine(++i==i++); 结果位true
30. as和is的区别    
    as在转换的同时判断兼容性，如果无法进行转换，返回位null（没有产生新的对象），as转换是否成功判断的依据是是否位null is只是做类型兼容性判断，并不执行真正的类型转换，返回true或false，对象为null也会返回false。
as比is效率更高，as只需要做一次类型兼容检查

## .NET面试题汇总系列(二)：面向对象
1. 什么是构造函数？
* 概念：构造函数的方法名与类型相同、没有返回类型

* 作用：完成对类的对象初始化

  * 创建一个类的新对象时，系统会自动调用该构造函数初始化新对象， 如果没有写定义，那么系统会自动提供一个不带任何参数的public 构造函数

2. class和struct的区别?
* 相同点 都可以实现接口

* 不同点

  1. class是引用类型，struct是值类型
  2. class允许继承、被继承，struct不允许，只能继承接口
  3. class可以初始化变量，struct不可以
  4. class可以有无参的构造函数，struct不可以，必须是有参的构造函数，而且在有参的构造函数必须初始化所有成员
* 使用场景

  1. Class比较适合大的和复杂的数据，表现抽象和多级别的对象层次时。
  2. Struct适用于作为经常使用的一些数据组合成的新类型，表示诸如点、矩形等主要用来存储数据的轻量级对象时，偏简单值。
  3. Struct有性能优势，Class有面向对象的扩展优势。
3. 简述一下面向对象的三大特性？
* 封装、继承、多态。
* 封装：是通过把对象的属性的实现细节隐藏起来，仅对外提供公共的访问方法。
* 继承：是通过子类继承基类、继承抽象类、继承接口实现的。
* 多态：是通过重写基类的override 方法、重写虚方法实现的。 好处是：方便维护、易扩展。 缺点是：比面向过程性能低。
4. 构造函数是否能被重写？
构造器Constructor不能被继承，因此不能重写，但可以被重载

5. 抽象类和接口有什么区别？
* 相同点：都不能直接实例化 
* 不同点：
  1. 抽象类用abstract修饰、接口用interface修饰
  2. 抽象类中的方法可以实现，也可以不实现，有抽象方法的类一定要用abstract修饰，接口中的方法不允许实现
  3. 抽象类只能单继承，接口支持多实现
  4. 抽象类有构造方法，接口不能有构造方法
  5. 接口只负责功能的定义，通过接口来规范类的，（有哪些功能），而抽象类即负责功能的定义有可以实现功能（实现了哪些功能）
  6. 类的执行顺序？
     * 执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法

7. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？
   * 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实现类，但前提是实现类必须有明确的构造函数。

8. 继承最大的好处？
   * 对父类成员进行重用，增加代码的可读性、灵活性。

9. 请说说引用和对象?
   * 对象和引用时分不开的，对象生成一个地址，放在堆里面，引用则指向这个地址，放在栈里面

10. 什么是匿名类，有什么好处？
    * 不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。

11. 重写和重载的区别?
* 重写方法：关键字用override修饰，派生类重写基类的方法，方法命名、返回类型，参数必须相同
* 重载方法：方法名必须相同，参数列表必须不相同，返回类型可以不相同。
* 作用：重写主要是实现面向对象的多态性、重载主要是实现实例化不同的对象
12. C#中有没有静态构造函数，如果有是做什么用的？
* 特点：静态构造函数既没有访问修饰符，也没有参数。在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数来初始化类。无法直接调用静态构造函数。在程序中，用户无法控制何时执行静态构造函数。 
* 用途：当类使用日志文件时，将使用这种构造函数向日志文件中写入项。

13. 怎样理解静态变量？静态成员和非静态成员的区别？
* 静态变量属于类，而不属于对象；并对所有对象所享；静态成员在加类的时候就被加载。

14. 属性能在接口中声明吗？
* 可以，不能有访问修饰符，不能初始化赋值。

15. 在项目中为什么使用接口？接口的好处是什么？什么是面向接口开发？
    * 接口是一种约束，描述类的公共方法/公共属性，不能有任何的实现
    * 好处是：结构清晰，类之间通信简单易懂，扩展性好，提高复用性。
    * 面向interface编程，原意是指面向抽象协议编程，实现者在实现时要严格按协议来办。
16. 什么时候用重载？什么时候用重写？
* 当一个类需要用不同的实现来做同一件事情，此时应该用重写，而重载是用不同的输入做同一件事情

17. 静态方法可以访问非静态变量吗？如果不可以为什么？
* 静态方法和非静态变量不是同一生命周期，静态方法属于类，非静态变量属于具体的对象，静态方法和具体的对象没有任何关联

18. 在.Net中所有可序列化的类都被标记为_?
* [serializable]

19. C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
* 一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质

20. 当使用new B()创建B的实例时，产生什么输出？
    ```C#
       using System;
        class A
        {
              public A()
              {
                    PrintFields();
              }
              public virtual void PrintFields(){}
          }
          class B:A
          {
               int x=1;
               int y;
               public B()
               {
                   y=-1;
               }
               public override void PrintFields()
               {
                   Console.WriteLine("x={0},y={1}",x,y);
               }
         }
    答：X=1,Y=0;
    ```

21. 能用foreach遍历访问的对象需要实现 ____接口或声明____方法的类型
* 答：IEnumerable 、 GetEnumerator。

## .NET/C#⾯试题汇总系列：集合、异常、泛型、LINQ、委托、EF！
1. IList 接⼝与List的区别是什么?
* IList 泛型接⼝是 Icollection 接⼝的⼦代，并且是所有⾮泛型列表的基接⼝。 
* Ilist 实现有三种类别：只读、固定⼤⼩、可变⼤⼩。 ⽆法修改只读 Ilist。 固定⼤⼩的 Ilist 不允许添加或移除元素，但允许修改现
  有元素。 可变⼤⼩的 Ilist 允许添加、移除和修改元素。
* IList 是个接⼝,定义了⼀些操作⽅法这些⽅法要你⾃⼰去实现，当你只想使⽤接⼝的⽅法时,这种⽅式⽐较
  好.他不获取实现这个接⼝的类的其他⽅法和字段，有效的节省空间．
* List 是个类型已经实现了IList 定义的那些⽅法。
2. 泛型的主要约束和次要约束是什么？-
*  当⼀个泛型参数没有任何约束时，它可以进⾏的操作和运算是⾮常有限的，因为不能对实参进⾏任何类型上的保证，
   这时候就需要⽤到泛型约束。泛型的约束分为：主要约束和次要约束，它们都使实参必须满⾜⼀定的规范，
   C#编译器在编译的过程中可以根据约束来检查所有泛型类型的实参并确保其满⾜约束条件。
* 主要约束
   * ⼀个泛型参数⾄多拥有⼀个主要约束，主要约束可以是⼀个引⽤类型、class或者struct。如果指定⼀个引⽤类型（class），
     那么实参必须是该类型或者该类型的派⽣类型。相反，struct则规定了实参必须是⼀个值类型。下⾯的代码展示了泛型参数主要约束：
    ```C#
     public class ClassT1<T> where T : Exception
     {
        private T myException;
        public ClassT1(T t)
        {
            myException = t;
        }
        public override string ToString()
        {
            // 主要约束保证了myException拥有source成员
            return myException.Source;
        }
    }
    public class ClassT2<T> where T : class
    {
        private T myT;
        public void Clear()
        {
            // T是引⽤类型，可以置null
            myT = null;
        }
    }
    public class ClassT3<T> where T : struct
    {
        private T myT;
        public override string ToString()
        {
            // T是值类型，不会发⽣NullReferenceException异常
            return myT.ToString();
        }
    }
    ```
* 次要约束
  * 次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型，可以有0到⽆限的次要约束，次要约束规定了实参必须实现所有的次要约束中规定的接⼝。
    次要约束与主要约束的语法基本⼀致，区别仅在于提供的不是⼀个引⽤类型⽽是⼀个或多个接⼝。例如我们为上⾯代码中的ClassT3增加⼀个次要约束：
    ```C#
    public class ClassT3<T> where T : struct, IComparable
    {
        ......
    }
    ```
3. 如何把⼀个array复制到arrayist⾥?
    ```C#
    foreach( object arr in array)
    {
        arrayist.Add(arr);
    }
    ```
4. List, Set, Map是否继承⾃Collection接⼝?
List，Set是，Map不是
5. Set⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?
* Set⾥的元素是不能重复的，那么⽤iterator()⽅法来区分重复与否。
* equals()是判读两个Set是否相等。equals()和==⽅法决定引⽤值是否指向同⼀对像，equals()在类中被覆盖，
  为的是当两个分离的对象的内容和类型相配的话，返回真值。
6. 有50万个int类型的数字，现在需要判断⼀下⾥⾯是否存在重复的数字，请你简要说⼀下思路。
* 使⽤C#的List集合⾃带的去重⽅法，例如 Distinct()，GroupBy()等。
* 利⽤ Dictionary 的Key值唯⼀的特性，HashSet 元素值唯⼀的特性 进⾏判断。
7. 数组有没有length()这个⽅法? String有没有length()这个⽅法 ？
* 数组没有length()这个⽅法，有length的属性。String有有length()这个⽅法。
8. ⼀个整数List中取出最⼤数（找最⼤值）。不能⽤Max⽅法。
    ```C#
    private static int GetMax(List<int> list)
    {
        int max = list[0];
        for (int i = 0; i < list.Count; i++)
        {
            if (list[i]>max)
            {
                max = list[i];
            }   
        }
        return max;
    }
    ```
9. C#异常类有哪些信息？
* C#中，所有异常都继承⾃System.Exception类，Exception类定义了C#异常应该具有的信息和⽅法。值得注意的属性有：
    ```C#
    public virtual string Message { get; }// 错误的信息，⽂字描述
    public virtual string StackTrace { get; }// 发⽣异常的调⽤堆栈信息
    public System.Reflection.MethodBase TargetSite { get; }//引发这个错误的⽅法
    public Exception InnerException { get; }// ⼦异常
    ```
10. 如何创建⼀个⾃定义异常？
* 根据类继承原则和异常处理原则，我们可以使⽤以下⽅式来⾃定义⼀个类：
    ```C#
    public class CustomException:Exception{}
    ```
11. 利⽤IEnumerable实现斐波那契数列⽣成?
    ```C#
    IEnumerable<int> GenerateFibonacci(int n)
    {
        if (n >= 1) yield return 1;
    
        int a = 1, b = 0;
        for (int i = 2; i <= n; ++i)
        {
            int t = b;
            b = a;
            a += t;
            yield return a;
        }
     }
     ```
12. 请利⽤ foreach 和 ref 为⼀个数组中的每个元素加 1
* 注意 foreach 不能⽤ var ，也不能直接⽤ int ，需要 ref int ，注意 arr 要转换为 Span 。
    ```C#
    int[] arr = { 1, 2, 3, 4, 5};
    Console.WriteLine(string.Join(",", arr)); // 1,2,3,4,5
    foreach (ref int v in arr.AsSpan())
    {
        v++;
    }
    Console.WriteLine(string.Join(",", arr)); // 2,3,4,5,6
    ```
13. 如何针对不同的异常进⾏捕捉？
    ```C#
    public class Program
    {
        public static void Main(string[] args)
        {
            Program p = new Program();
            p.RiskWork();
    
            Console.ReadKey();
        }
    
        public void RiskWork()
        {
            try
            {
                // ⼀些可能会出现异常的代码
            }
            catch (NullReferenceException ex)
            {
                HandleExpectedException(ex);
            }
            catch (ArgumentException ex)
            {
                HandleExpectedException(ex);
            }
            catch (FileNotFoundException ex)
            {
                HandlerError(ex);
            }
            catch (Exception ex)
            {
                HandleCrash(ex);
            }
        }
        //这⾥处理预计可能会发⽣的，不属于错误范畴的异常
        private void HandleExpectedException(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
        }
    
        // 这⾥处理在系统出错时可能会发⽣的，⽐较严重的异常
        private void HandlerError(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
            // 严重的异常需要抛到上层处理
            throw ex;
        }
    
        // 这⾥处理可能会导致系统崩溃时的异常
        private void HandleCrash(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
            // 关闭当前程序
            System.Threading.Thread.CurrentThread.Abort();
        }
    }
    ```
14. 如何避免类型转换时的异常？
* 其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类引⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。
* 当⼀个不正确的类型转换发⽣时，会产⽣InvalidCastException异常，有时我们会⽤try-catch块做⼀些尝试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源的机制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较⾼，并且在尝试性类型转换时，这些信息都没有意义。在.NET中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。
  1. is 只负责检查类型的兼容性，并返回结果：true 和 false。→ 进⾏类型判断;
    ```C#
    public static void Main(string[] args)
    {
        object o = new object();
        // 执⾏类型兼容性检查
        if(o is ISample)
        {
        // 执⾏类型转换
        ISample sample = (ISample)o;
        sample.SampleShow();
        }
        Console.ReadKey();
     }
    ```
  2. as 不仅负责检查兼容性还会进⾏类型转换，并返回结果，如果不兼容则返回 null 。→ ⽤于类型转型
    ```c#
    public static void Main(string[] args)
    {
        object o = new object();
        // 执⾏类型兼容性检查
        ISample sample = o as ISample;
        if(sample != null)
        {
            sample.SampleShow();
        }
        Console.ReadKey();
     }
    ``` 
  * 两者的共同之处都在于：不会抛出异常！综上⽐较，as 较 is 在执⾏效率上会好⼀些，在实际开发中应该
    量才⽽⽤，在只进⾏类型判断的应⽤场景时，应该多使⽤ is ⽽不是 as。
15. Serializable特性有什么作⽤？
  * 通过上⾯的流类型可以⽅便地操作各种字节流，但是如何把现有的实例对象转换为⽅便传输的字节流，就
    需要使⽤序列化技术。对象实例的序列化，是指将实例对象转换为可⽅便存储、传输和交互的流。在.NET
    中，通过Serializable特性提供了序列化对象实例的机制，当⼀个类型被申明为Serializable后，它就能被
    诸如BinaryFormatter等实现了IFormatter接⼝的类型进⾏序列化和反序列化。
16. 委托是什么?
  * 委托是寻址的.NET版本。在C++中，函数指针只不过是⼀个指向内存位置的指针，它不是类型安全的。我
    们⽆法判断这个指针实际指向什么，像参数和返回类型等项久更⽆从知晓了。
  * ⽽.NET委托完全不同，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对⽅法的
    引⽤，也可以包含对多个⽅法的引⽤。
17. 如何⾃定义委托？
  * 声明⼀个委托类型，它的实例引⽤⼀个⽅法，该⽅法获取⼀个int参数，返回void。
  > public delegate void Feedback(int num);
  * 理解委托的⼀个要点是它们的安全性⾮常⾼。在定义委托时，必须给出它所表示的⽅法的签名和返回类型
    等全部细节。
  * 理解委托的⼀种⽐较好的⽅式是把委托当作这样⼀件事情：它给⽅法的签名和返回类型指定名称.
  * 其语法类似于⽅法的定义，需要在定义⽅法的前⾯加上delegate关键字。定义委托基本上就是定义⼀个新
    的类，所以可以在任何地⽅定义类的相同地⽅定义委托，也就是说，可以在另⼀个类的内部定义，也可以
    在任何类的外部定义，还可以在名称控件中把委托定义为定义为顶层对象。访问修饰符可以是
    public/private/protected等。
18. NET默认的委托类型有哪⼏种？
    1. Action < T >
       * 泛型Action委托表示引⽤⼀个void返回类型的⽅法。这个委托类存在16种重载⽅法。
    2. Func< T >
       * Func调⽤带返回类型的⽅法。有16种重载⽅法
       * 例如Func委托类型可以调⽤带返回类型且⽆参数的⽅法，Func<in T,out TResult>委托类型调⽤带有4个
         参数和⼀个返回类型的⽅法。
19. 什么是泛型委托？
  * Action就是泛型委托。
  * 注意事项：
    1. 建议尽量使⽤这些委托类型，⽽不是在代码中定义更多的委托类型。这样可以减少系统中的类型数⽬，同
      时简化编码
    2. 如果需要使⽤ref或out关键字，以传引⽤的⽅式传递⼀个参数，就可能不得不定义⾃⼰的委托：
      delegate void Test(ref int i)
    3. 如果委托要通过C#的params关键字获取可变数量的额参数，要为委托的任何桉树指定默认值，或者要
      对委托的泛型类型参数进⾏约束，也必须定义⾃⼰的委托类型
      delegate void EventHandler(Object sender, TEventArgs e)
      where TEventArgs : EventArgs;
    4. 使⽤获取泛型实参和返回值的委托时，可利⽤逆变与协变。逆变：⽗类转换为⼦类；协变：⼦类转换为
      ⽗类。
20. 什么是匿名⽅法?
  * 匿名⽅法是⽤作委托的参数的⼀段代码。
      ```C#
        //匿名⽅法,例1
        Func<int, int> anon = delegate(int i)
        {
            i = i+1;
            return i;
        };
        //输出2
        Console.WriteLine(anon(1));
        //匿名⽅法,例2
        Action<int> anon2 = delegate(int i)
        {
            i = i + 1;
        };
        //输出2
        Console.WriteLine(anon(1));
      ```
21. 什么是闭包？
  * 通过Lambda表达式可以访问Lambda表达式块外部的变量，这成为闭包。
  * 当引⽤外部变量时，需要注意，外部变量变化时，lambda表达式的结果也可能会随着外部变量变化⽽变
    化。
  * 如下⾯的例⼦：
      ```C#
        int y = 5;
        Func<int, int> lambda = x => x + y;
        Console.WriteLine(lambda(1));
        y = 10;
        Console.WriteLine(lambda(1));
      ```
22. EF(Entity Framework)是什么？
  * 实体框架EF是http://ADO.NET中的⼀组⽀持开发⾯向数据的软件应⽤程序的技术，是微软的⼀个ORM框
    架。
  * 主要有三种⽅式:
    * Database FirstDatabase First”模式:我们称之为“数据库优先”，前提是你的应⽤已经有相应的数据库，你可以使⽤EF设计⼯具根据数据库⽣成
      数据数据类，你可以使⽤Visual Studio模型设计器修改这些模型之间对应关系。
    * Model FirstModel First:我们称
      之为“模型优先”，这⾥的模型指的是“ADO.NET Entity Framework Data Model”，此时你的应⽤并没有
      设计相关数据库，在Visual Studio中我们通过设计对于的数据模型来⽣成数据库和数据类。
    * Code FirstCode First:我们称之为“代码优先”模式，是从EF4.1开始新建加⼊的功能。
    * 使⽤Code First模式进⾏EF开发时开发⼈员只需要编写对应的数据类（其实就是领域模型的实现过程），
      然后⾃动⽣成数据库。这样设计的好处在于我们可以针对概念模型进⾏所有数据操作⽽不必关⼼数据的存
      储关系，使我们可以更加⾃然的采⽤⾯向对象的⽅式进⾏⾯向数据的应⽤程序开发。
23. 什么是ORM?
  * ORM指的是⾯向对象的对象模型和关系型数据库的数据结构之间的互相转换。(表实体跟表之间的相互转换)
  * ORM框架有很多，EF框架是ORM框架的其中⼀种，是实现了ORM思想的框架。  
    O=>表实体  
    M=>映射关系  
    R=>数据库.表
24. 为什么⽤EF⽽不⽤原⽣的ADO.NET?
  * 极⼤的提⾼开发效率:EF是微软⾃⼰的产品,开发中代码都是强类型的, EF代码效率⾮常⾼,⾃动化程度⾮常⾼,命令式的编程.
  * EF提供的模型设计器⾮常强⼤,不仅仅带来了设计数据库的⾰命,也附带来的⾃动化模型代码的功能也极⼤的提⾼开发和架构设计的效率.
  * EF跨数据⽀持的是ORM框架主要功能点之⼀,带来的是可以通过仅仅改变配置就可以做到跨数据库的能⼒. 
25. 如何提⾼LINQ性能问题？
    * 提升从数据库中拿数据的速度，可以参考以下⼏种⽅法：
    1. 在数据库中的表中定义合适的索引和键
    2. 只获得你需要的列（使⽤ViewModel或者改进你的查询）和⾏（使⽤IQueryable）
    3. 尽可能使⽤⼀条查询⽽不是多条
    4. 只为了展示数据，⽽不进⾏后续修改时，可以使⽤AsNoTracking。它不会影响⽣成的SQL，但它可以令系统少维护很多数据，从⽽提⾼性能
    5. 使⽤Reshaper等⼯具，它可能会在你写出较差的代码时给出提醒.
26. 什么是协变和逆变?
27. 什么是IEnumerable？
    * IEnumerable及IEnumerable的泛型版本IEnumerable是⼀个接⼝，它只含有⼀个⽅法GetEnumerator。
      Enumerable这个静态类型含有很多扩展⽅法，其扩展的⽬标是IEnumerable。
    * 实现了这个接⼝的类可以使⽤Foreach关键字进⾏迭代（迭代的意思是对于⼀个集合，可以逐⼀取出元素
      并遍历之）。实现这个接⼝必须实现⽅法GetEnumerator。
28. IEnumerable的缺点有哪些？
    * IEnumerable功能有限，不能插⼊和删除。
    * 访问IEnumerable只能通过迭代，不能使⽤索引器。迭代显然是⾮线程安全的，每次IEnumerable都会⽣成新的IEnumerator，从⽽形成多个互相不影响的迭代过程。
    * 在迭代时，只能前进不能后退。新的迭代不会记得之前迭代后值的任何变化。
29. 延迟执⾏ (Lazy Loading)是什么？
    * ⼤部分LINQ语句是在最终结果的第⼀个元素被访问的时候（即在foreach中调⽤MoveNext⽅法）才真正
      开始运算的，这个特点称为延迟执⾏。⼀般来说，返回另外⼀个序列（通常为IEnumerable或
      IQueryable）的操作，使⽤延迟执⾏，⽽返回单⼀值的运算，使⽤⽴即执⾏。
    * IEnumerable是延迟执⾏的，当没有触发执⾏时，就不会进⾏任何运算。Select⽅法不会触发LINQ的执
      ⾏。⼀些触发的⽅式是：foreach循环，ToList，ToArray，ToDictionary⽅法等. 
30. LINQ可视化⼯具简单介绍⼀下？
    * LINQPad工具可以连接到已经存在的数据库（不过就仅限微软的SQL Server系，如果要连接到其
    他类型的数据库则需要安装插件）。某种程度上可以代替SQL Management Studio，是使⽤SQL
    Management Studio作为数据库管理软件的码农的强⼒⼯具，可以⽤于调试和性能优化（通过改善编译后
    的SQL规模）。
    * LINQPad⽀持使⽤SQL或C#语句（点标记或查询表达式）进⾏查询。你也可以通过点击橙⾊圈内的各种不
      同格式，看到查询表达式的各种不同表达⽅式：
      * Lambda：查询表达式的Lambda表达式版本，
      * SQL：由编译器转化成的SQL，通常这是我们最关⼼的部分，
      * IL：IL语⾔
31. LINQ to Object和LINQ to SQL有何区别？
    * LINQ to SQL可以将查询表达式转换为SQL语句，然后在数据库中执⾏。相⽐LINQ to Object，则是将查
    询表达式直接转化为Enumerable的⼀系列⽅法，最终在C#内部执⾏。LINQ to Object的数据源总是实现
    IEnumerable（所以不如叫做LINQ to IEnumerable），相对的，LINQ to SQL的数据源总是实现
    IQueryable并使⽤Queryable的扩展⽅法。
    * 将查询表达式转换为SQL语句并不保证⼀定可以成功. 
32. 除了EF，列举出你知道的ORM框架
    * dapper EntityFramework、 EJB、Hibernate、IBATIS、TopLink、OJB
33. 如何如何获取EF⽣成的Sql脚本
    1. 可以调试起来通过SqlServerProfiler 来获取Sql 
    2. EF Dbcontext 注册⽇志事件输出⽇志查看Sql
34. 在哪些类型额项⽬中你会选择EF? 为什么？
    * EF主要是以⾯向对象的思想来做数据库数据操作，对Sql语句能⼒没什么要
    求，开发使⽤效率⾼！便于上⼿，⼀般来说，使⽤EF框架，肯定会⽐直接使⽤ADO.NET，消耗的时间多⼀
    些。 所以在⼀般企业级开发，管理型系统，对数据性能要求不是特别⾼的情况下，优先选择EF,这样可以
    ⼤⼤的推进开发效率！如果像⼀些互联⽹项⽬中，对性能要求精度很⾼！可以另外做技术选型，选择原⽣
    ADO.NET。
35. 请说明EF中映射实体对象的⼏种状态？
    * Detached：该实体未由上下⽂跟踪。刚使⽤新运算符或某个 System.Data.Entity.DbSet Create ⽅法创
    建实体后，实体就处于此状态。
    * Unchanged：实体将由上下⽂跟踪并存在于数据库中，其属性值与数据库中的值相同。
    * Added：实体将由上下⽂跟踪，但是在数据库中还不存在。
    * Deleted：实体将由上下⽂跟踪并存在于数据库中，但是已被标记为在下次调⽤ SaveChanges 时从数据
    库中删除。
    * Modified：实体将由上下⽂跟踪并存在于数据库中，已修改其中的⼀些或所有属性值。
36. 如果实体名称和数据库表名不⼀致，该如何处理？
    * 实体名称和数据库表名称不⼀致：可以通过使⽤TableAttribute 特性； 
37. 泛型的优点有哪些？
    * 代码的可重⽤性。⽆需从基类型继承，⽆需重写成员。
    * 扩展性好。
    * 类型安全性提⾼。 泛型将类型安全的负担从你那⾥转移到编译器。 没有必要编写代码来测试正确的数据类
    型，因为它会在编译时强制执⾏。 降低了强制类型转换的必要性和运⾏时错误的可能性。 
    * 性能提⾼。泛型集合类型通常能更好地存储和操作值类型，因为⽆需对值类型进⾏装箱。
38. try {}⾥有⼀个return语句，那么紧跟在这个try后的finally {}⾥的code会不会被执⾏，什么时候被执⾏，在return前还是后?
    * 会执⾏，在return前执⾏。
39. C# 中的异常类有哪些？
    * C# 异常是使⽤类来表示的，异常类主要是直接或间接地派⽣于 System.Exception 类。
    * System.ApplicationException 和 System.SystemException 类是派⽣于 System.Exception 类的异常
    类。
    * System.ApplicationException 类⽀持由应⽤程序⽣成的异常，所以我们⾃⼰定义的异常都应派⽣⾃该
    类。
    * System.SystemException 类是所有预定义的系统异常的基类。
    * System.IO.IOException  ⽤于处理 I/O 错误(读写⽂件)。
    * System.IndexOutOfRangeException ⽤于处理当⽅法指向超出范围的数组索引时⽣成的错误。
    * System.ArrayTypeMismatchException  ⽤于处理当数组类型不匹配时⽣成的错误。
    * System.NullReferenceException  ⽤于处理当依从⼀个空对象时⽣成的错误。
    * System.DivideByZeroException ⽤于处理当除以零时⽣成的错误。例如：100/0就会报这个错误。
    * System.InvalidCastException  ⽤于处理在类型转换期间⽣成的错误。
    * System.OutOfMemoryException  ⽤于处理空闲内存不⾜⽣成的错误。
    * System.StackOverflowException  ⽤于处理栈溢出⽣成的错误。
40. 泛型有哪些常⻅的约束？
    * 泛型约束 public void GetEntity() where T:class
    * where T :struct //约束T必须为值类型
    * where K : class //约束K必须为引⽤类型
    * where V : IComparable //约束V必须是实现了IComparable接⼝
    * where W : K //要求W必须是K类型，或者K类型的⼦类
    * where X :class ,new () // 或者写出 new class();X必须是引⽤类型，并且要有⼀个⽆参的构造函数（对于⼀个类型有多有约束，中间⽤逗号隔开）
41. Collection和Collections的区别？
    * Collection 是集合类的上级接⼝，Collections 是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实
    现对各种集合的搜索，排序，线程安全化操作。
42. 能⽤foreach 遍历访问的对象的要求？
    * 需要实现IEnumerable接⼝或声明GetEnumerator⽅法的类型。
43. 说出五个集合类？
    * List：泛型类；
    * Stack：堆栈，后进先出的访问各个元素
    * Dictionary<TKey, TValue>：字典类，key是区分⼤⼩写；value⽤于存储对应于key的值
    * HashSet：此集合类中不能有重复的⼦元素
    * SortedList<TKey, TValue>：排序列表，key是排好序的数组。
44. C#可否对内存进⾏直接的操作？
    * C#在Unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针。
      1. 在 Visual Studio 开发环境中设置/unsafe（启⽤不安全模式)编译器选项  
        打开项⽬的“属性”⻚。  
        单击“⽣成”属性⻚。 
        选中“允许不安全代码”复选框。  
      2. unsafe关键字表示不安全上下⽂，该上下⽂是任何涉及指针的操作所必需的。  
        可以在类型或成员的声明中使⽤ unsafe修饰符。 
         因此，类型或成员的整个正⽂范围均被视为不安全上下⽂。例如，以下是⽤ unsafe 修饰符声明的⽅法：
      ```C#
       unsafe static void FastCopy(byte[] src, byte[] dst, int count)
       {
           // Unsafe context: can use pointers here.
       }
      ```
      不安全上下⽂的范围从参数列表扩展到⽅法的结尾，因此指针在以下参数列表中也可以使⽤：
      ```C#
       unsafe static void FastCopy ( byte* ps, byte* pd, int count )
       {...}
      ```
      还可以使⽤不安全块从⽽能够使⽤该块内的不安全代码。例如：
      ```C#
       unsafe
       {
           // Unsafe context: can use pointers here.
       }
      ```
      若要编译不安全代码，必须指定 /unsafe编译器选项。
      ⽆法通过公共语⾔运⾏库验证不安全代码。
45. HashMap和Hashtable区别
    Collection是集合类的上级接⼝，Collections是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实现
    对各种集合的搜索，排序，线程安全化操作。

## .NET/C#⾯试题汇总系列：多线程
1. 根据线程安全的相关知识，分析以下代码，当调⽤test⽅法时i>10时是否会引起死锁?并简
要说明理由。
    ```C#
       public void test(int i)
       {
       lock(this)
       {
       if (i>10)
       {
       i--;
       test(i);
       }
       }
       }
    ```
   * 不会发⽣死锁，（但有⼀点int是按值传递的，所以每次改变的都只是⼀个副本，因此不会出现死锁。但如
     果把int换做⼀个object，那么死锁会发⽣）
2. 描述线程与进程的区别？
   * 线程(Thread)与进程（Process）⼆者都定义了某种边界，不同的是进程定义的是应⽤程序与应⽤程序之
   间的边界，不同的进程之间不能共享代码和数据空间，⽽线程定义的是代码执⾏堆栈和执⾏上下⽂的边
   界。⼀个进程可以包括若⼲个线程，同时创建多个线程来完成某项任务，便是多线程。
   * ⽽同⼀进程中的不同线程共享代码和数据空间。⽤⼀个⽐喻来说，如果⼀个家庭代表⼀个进程，在家庭内
   部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进⾏积累，同时也有权利对家庭财富进
   ⾏消费，当⾯对⼀个任务的时候，家庭也可以派出⼏个成员来协同完成，⽽家庭之外的⼈则没有办法直接
   消费不属于⾃⼰家庭的财产.
3. Windows单个进程所能访问的最⼤内存量是多少？它与系统的最⼤虚拟内存⼀样吗？这对于系统设计有什么影响？
   * 这个需要针对硬件平台，公式为单个进程能访问的最⼤内存量=2的处理器位数次⽅/2，⽐如通常情况下，
   32位处理器下，单个进程所能访问的最⼤内存量为:232 /2 = 2G 。单个进程能访问的最⼤内存量是最⼤
   虚拟内存的1/2，因为要分配给操作系统⼀半虚拟内存。
4. using() 语法有⽤吗？什么是IDisposable?
   * 有⽤，实现了IDisposable的类在using中创建，using结束后会⾃定调⽤该对象的Dispose⽅法，释放资
   源。
5. 前台线程和后台线程有什么区别？
   * 通过将 Thread.IsBackground 属性设置为 true，就可以将线程指定为后台线程
   * 前台线程： 应⽤必须结束掉所有的前台线程才能结束程序，只要有⼀个前台线程没退出进程就不会⾃动退
   出，当然线程是依附在进程上的，所以你直接把进程KO掉了的话⾃然所有前台线程也会退出。
   * 后台线程： 进程可以不考虑后台直接⾃动退出，进程⾃动退出后所有的后台线程也会⾃动销毁。
6. 什么是互斥？
   * 当多个线程访问同⼀个全局变量，或者同⼀个资源(⽐如打印机)的时候，需要进⾏线程间的互斥操作来保证
   访问的安全性。
7. 如何查看和设置线程池的上下限?
   * 线程池的线程数是有限制的，通常情况下，我们⽆需修改默认的配置。但在⼀些场合，我们可能需要了解
   线程池的上下限和剩余的线程数。线程池作为⼀个缓冲池，有着其上下限。在通常情况下，当线程池中的
   线程数⼩于线程池设置的下限时，线程池会设法创建新的线程，⽽当线程池中的线程数⼤于线程池设置的
   上限时，线程池将销毁多余的线程。
   * PS：在.NET Framework 4.0中，每个CPU默认的⼯作者线程数量最⼤值为250个，最⼩值为2个。⽽IO
   线程的默认最⼤值为1000个，最⼩值为2个。
   * 在.NET中，通过 ThreadPool 类型提供的5个静态⽅法可以获取和设置线程池的上限和下限，同时它还额
   外地提供了⼀个⽅法来让程序员获知当前可⽤的线程数量，下⾯是这五个⽅法的签名:
     1. static void GetMaxThreads(out int workerThreads, out int completionPortThreads)
     2. static void GetMinThreads(out int workerThreads, out int completionPortThreads)
     3. static bool SetMaxThreads(int workerThreads, int completionPortThreads)
     4. static bool SetMinThreads(int workerThreads, int completionPortThreads)
     5. static void GetAvailableThreads(out int workerThreads, out int completionPortThreads)
8. Task状态机的实现和⼯作机制是什么？
   * CPS全称是Continuation Passing Style，在.NET中，它会⾃动编译为： 
     1. 将所有引⽤的局部变量做成
     闭包，放到⼀个隐藏的状态机的类中； 
     2. 将所有的await展开成⼀个状态号，有⼏个await就有⼏个状态号； 
     3. 每次执⾏完⼀个状态，都重复回调状态机的MoveNext⽅法，同时指定下⼀个状态号； 4.
     MoveNext⽅法还需处理线程和异常等问题。
9. await的作⽤和原理，并说明和GetResult()有什么区别？
   * 从状态机的⻆度出发，await的本质是调⽤Task.GetAwaiter()的UnsafeOnCompleted(Action)回调，并
   指定下⼀个状态号。
   * 从多线程的⻆度出发，如果await的Task需要在新的线程上执⾏，该状态机的MoveNext()⽅法会⽴即返
   回，此时，主线程被释放出来了，然后在UnsafeOnCompleted回调的action指定的线程上下⽂中继续
   MoveNext()和下⼀个状态的代码。
   * ⽽相⽐之下，GetResult()就是在当前线程上⽴即等待Task的完成，在Task完成前，当前线程不会释放。
   注意：Task也可能不⼀定在新的线程上执⾏，此时⽤GetResult()或者await就只有会不会创建状态机的区
   别了。
10. Task和Thread有区别吗？
    * Task和Thread都能创建⽤多线程的⽅式执⾏代码，但它们有较⼤的区别。Task较新，发布于.NET 4.5，
    能结合新的async/await代码模型写代码，它不⽌能创建新线程，还能使⽤线程池（默认）、单线程等⽅
    式编程，在UI编程领域，Task还能⾃动返回UI线程上下⽂，还提供了许多便利API以管理多个Task。
11. 多线程有什么⽤？
    1. 发挥多核CPU的优势：
    随着⼯业的进步，现在的笔记本、台式机乃⾄商⽤的应⽤服务器⾄少也都是双核的，4核、8核甚⾄16核的
    也都不少⻅，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核
    CPU上所谓的”多线程”那是假的多线程，同⼀时间处理器只会处理⼀段逻辑，只不过线程之间切换得⽐较
    快，看着像多个线程”同时”运⾏罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时
    ⼯作，多线程，可以真正发挥出多核CPU的优势来，达到充分利⽤CPU的⽬的。
    2. 防⽌阻塞：
    从程序运⾏效率的⻆度来看，单核CPU不但不会发挥出多线程的优势，反⽽会因为在单核CPU上运⾏多线
    程导致线程上下⽂的切换，⽽降低程序整体的效率。但是单核CPU我们还是要应⽤多线程，就是为了防⽌
    阻塞。试想，如果单核CPU使⽤单线程，那么只要这个线程阻塞了，⽐⽅说远程读取某个数据吧，对端迟
    迟未返回⼜没有设置超时时间，那么你的整个程序在数据返回回来之前就停⽌运⾏了。多线程可以防⽌这
    个问题，多条线程同时运⾏，哪怕⼀条线程的代码执⾏读取数据阻塞，也不会影响其它任务的执⾏。
    3. 便于建模：
    这是另外⼀个没有这么明显的优点了。假设有⼀个⼤的任务A，单线程编程，那么就要考虑很多，建⽴整个
    程序模型⽐较麻烦。但是如果把这个⼤的任务A分解成⼏个⼩任务，任务B、任务C、任务D，分别建⽴程
    序模型，并通过多线程分别运⾏这⼏个任务，那就简单很多了。
12. 两个线程交替打印0~100的奇偶数
       * 这道题就是说有两个线程，⼀个名为偶数线程，⼀个名为奇数线程，偶数线程只打印偶数，奇数线程只打
       印奇数，两个线程按顺序交替打印。
       ```C#
       public class ThreadExample
       {
            ///<summary>
            ///两个线程交替打印0~100的奇偶数
            ///</summary>
            public static void PrintOddEvenNumber
            {
                varwork = newTheadWorkTest;
                varthread1 = newThread(work.PrintOddNumer) { Name = "奇数线程"};
                varthread2 = newThread(work.PrintEvenNumber) { Name = "偶数线程"};
                thread1.Start;
                thread2.Start;
            }
       }
    
       public class TheadWorkTest
       {
    
            private static readonly AutoResetEvent oddAre = newAutoResetEvent(false);
    
            private static readonly AutoResetEvent evenAre = newAutoResetEvent(false);
    
            public void PrintOddNumer
            {
                oddAre.WaitOne;
                for( var0; i < 100; i++ )
                {
                    if(i % 2!= 1) continue;
                    Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");
                    evenAre.Set;
                    oddAre.WaitOne;
                }
            }
    
            public void PrintEvenNumber
            {
                    for( vari = 0; i < 100; i++ )
                    {
                        if(i % 2!= 0) continue;
                        Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");
                        oddAre.Set;
                        evenAre.WaitOne;
                    }
            }
       }
       ```
13. 为什么GUI不⽀持跨线程调⽤?有什么解决⽅法？
  * 因为GUI应⽤程序引⼊了⼀个特殊的线程处理模型，为了保证UI控件的线程安全，这个线程处理模型不允许其他⼦线程跨线程访问UI元素。解决⽅法⽐较多的：
    * 利⽤UI控件提供的⽅法，Winform是控件的Invoke⽅法，WPF中是控件的Dispatcher.Invoke⽅法；
    * 使⽤BackgroundWorker；
    * 使⽤GUI线程处理模型的同步上下⽂SynchronizationContext来提交UI更新操作
14. 说说常⽤的锁，lock是⼀种什么样的锁？
    * 常⽤的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是⼀个混
    合锁，其实质是Monitor
15. lock为什么要锁定⼀个参数（可否为值类型？）参数有什么要求？
    * lock的锁对象要求为⼀个引⽤类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不⼀
    样，会导致锁定⽆效。
    * 对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向⼀个真正的锁（同步
    块），这个锁（同步块）会被复⽤
16. 多线程和异步的区别和联系?
    * 多线程是实现异步的主要⽅式之⼀，异步并不等同于多线程。实现异步的⽅式还有很多，⽐如利⽤硬件的
    特性、使⽤进程或纤程等。
    * 在.NET中就有很多的异步编程⽀持，⽐如很多地⽅都有Begin 、End 的⽅法，就是⼀种异步编程⽀持，她
    内部有些是利⽤多线程，有些是利⽤硬件的特性来实现的异步编程。
17. 线程池的有点和不⾜?
    * 优点：减⼩线程创建和销毁的开销，可以复⽤线程；也从⽽减少了线程上下⽂切换的性能损失；在GC回收
    时，较少的线程更有利于GC的回收效率。
    * 缺点：线程池⽆法对⼀个线程有更多的精确的控制，如了解其运
    ⾏状态等；不能设置线程的优先级；加⼊到线程池的任务（⽅法）不能有返回值；对于需要⻓期运⾏的任
    务就不适合线程池。
18. Mutex和lock有什么不同？⼀般⽤哪⼀种⽐较好？
    * Mutex是⼀个基于内核模式的互斥锁，⽀持锁的递归调⽤，⽽Lock是⼀个混合锁，⼀般建议使⽤Lock更
    好，因为lock的性能更好。
19. ⽤双检锁实现⼀个单例模式Singleton。
       ```C#
       public static class Singleton<T> where T : class,new()
       {
           private static T _Instance;
           private static object _lockObj = new object();

           /// <summary>
           /// 获取单例对象的实例
           /// </summary>
           public static T GetInstance()
           {
               if (_Instance != null) return _Instance;
               lock (_lockObj)
               {
                   if (_Instance == null)
                   {
                       var temp = Activator.CreateInstance<T>();
                       System.Threading.Interlocked.Exchange(ref _Inance, temp);
                   }
               }   
               return _Instance;
           }
        }
       ```
20. Thread 类有哪些常⽤的属性和⽅法？
    * 属性：
      * CurrentContext：获取线程正在其中执⾏的当前上下⽂。
      * CurrentCulture：获取或设置当前线程的区域性。
      * CurrentPrincipal：获取或设置线程的当前负责⼈（对基于⻆⾊的安全性⽽⾔）。
      * CurrentThread：获取当前正在运⾏的线程。
      * CurrentUICulture：获取或设置资源管理器使⽤的当前区域性以便在运⾏时查找区域性特定的资源。
      * IsBackground：获取或设置⼀个值，该值指示某个线程是否为后台线程。
      * Priority：获取或设置⼀个值，该值指示线程的调度优先级。
      * ThreadState：获取⼀个值，该值包含当前线程的状态。
    * ⽅法:
      * public void Abort()
        在调⽤此⽅法的线程上引发 ThreadAbortException，以开始终⽌此线程的过程。调⽤此⽅法通常会终⽌
        线程。
      * `public static void ResetAbort()`;
        取消为当前线程请求的 Abort。
      * public void Start()
        开始⼀个线程。
      * `public static void Sleep( int millisecondsTimeout )`
        让线程暂停⼀段时间。
      * `public static bool Yield()`
        导致调⽤线程执⾏准备好在当前处理器上运⾏的另⼀个线程。由操作系统选择要执⾏的线程。
## .NET/C#⾯试题汇总系列：ASP.NET MVC
1. MVC中的TempData\ViewBag\ViewData区别?
   * TempData  保存在Session中，Controller每次执⾏请求的时候，会从Session中先获取 TempData，⽽
   后清除Session，获取完TempData数据，虽然保存在内部字典对象中，但是其集合中的每个条⽬访问⼀次
   后就从字典表中删 除，ViewData存的是Key/Value字典，使⽤时需要类型转换。
   * ViewBag和ViewData只在当前Action中有效，等同于View，ViewBag⽐ViewData慢，ViewBag存
   dynamic类型数据，使⽤时不需要类型转换
   * ViewData和ViewBag 中的值可以互相访问，因为ViewBag的实现中包含了ViewData，ViewData存的是
   Key/Value字典，使⽤时需要类型转换
2. 阐述下MVC框架的机制，各个模块的作⽤?
   * 所谓模型，就是MVC需要提供的数据源，负责数据的访问和维护。
   * 所谓视图，就是⽤于显示模型中数据的⽤户界⾯。
   * 所谓控制器，就是⽤来处理⽤户的输⼊，负责改变模型的状态并选择适当的视图来显示模型的数据。
3. ASP.NET和ASP.NET MVC的关系?
   * ASP.NET MVC是在核⼼ASP.NET基础之上构建的，从mvc命名空间System.Web.Mvc就能看出，因为
   System.Web是Asp.NET的核⼼命名空间。
   * ⽐如ASP.NET MVC依赖于HttpHandler，关于请求是怎么进⼊控制器的，其实就是⽤到了HttpHandler
   * Session、Cookie、Cache和Application这些ASP.NET的对象保存机制在MVC中依然是需要⽤到的
   * HttpContext、Request、Response、Server对象在MVC中仍然可以使⽤，在Controller中通过智能感知
   的形式很容易得到这些对象
4. MVC对ASP.NET好处在哪⾥？
   * 提供⾮常清晰的成绩管理，像ui层，也就是view, 数据层model和管理层controller。
   * 单元测试⽐较容易。
   * 改善了数据模型和视图的重⽤性。
   * 代码的结构更加优化。
5. 什么是razor view engine?
   * 这个引擎提供了数据绑定的显示模板。
   ```C#
    @model MvcStore.Models.Customer

    @{ViewBag.Title="Get Customers";}

    <div class="cust"><h3><em>@Model.CustomerName</em></h3></div>
   ```
6. view bag 和 view data之间的区别是什么?
   * view bag是view data的⼀个扩展。扩展以后可以创建动态的属性。这样的好处有:
     * 不需要进⾏类型的转换。
     * 我们可以使⽤dynamic关键字。
     * 但是有⼀个缺点就是view bag要⽐view data慢⼀些。
7. 解释⼀下sections?
   * Sections是html⻚⾯的⼀部分。`@rendersection("testsection")`
   * 在⼦⻚⾯中我们定义如下的sections。`@section testsection {<h1>test content</h1>}`
   * 如果这个section没有定义的话会出错，我们可以使⽤⼀个required属性来防⽌⻚⾯出错。`@rendersection("testsection", required: false)`
8. 为什么要使⽤html.partial?
   * 这个⽅法⽤来显示html string指定的某块视图。`html.partial("testpartialview")`
9. 什么是partial view？
   * Partial view相当于传统⽹⻚表格中的user controls.
   * 它的主要⽬的是为了重复使⽤这些视图，他们⼀般被放在⼀个共享⽂件夹⾥⾯`html.partial()/ html.renderpartial()`
10. MVC同时适⽤于Windows应⽤和Web应⽤吗?
    * 相⽐Windows应⽤，MVC架构更适⽤于Web应⽤。对于Windows应⽤，MVP(Model View Presenter )
    架构更好⼀点。如果你使⽤WPF和Silverlight，MVVM更适合。
11. 在MVC中如何保持Sessions?
    * 可以通过三种⽅式保持： tempdata, viewdata, 和viewbag。
12. 已经有了ASPX，为什么还要Razor?
    * 相⽐ASPX，Razor是⼀个⼲净的、轻量级的和语法更简单。例如，ASPX去显示时间：
    `<%=DateTime.Now%>`
    * 在Razor中，只需要⼀⾏：
    `@DateTime.Now`
13. 在MVC中如何去执⾏Windows认证？
    * 你需要修改web.config⽂件，并设置验证模式为Windows。
    ```java
    <authentication mode="Windows"/>
     <authorization>
     <deny users="?"/>
     </authorization>
    ```
    * 然后在controlle或action中，你可以使⽤ Authorize 属性，指定哪个⽤户可以访问这个controller或
    action。下⾯的代码设置到只有指定的⽤户可以访问它。
    ```C#
    [Authorize(Users= @"WIN-3LI600MWLQN\Administrator")]
    public class StartController : Controller
    {
        //
        // GET: /Start/
        [Authorize(Users = @"WIN-3LI600MWLQN\Administrator")]
        public ActionResult Index()
        {
           return View("MyView");
        }
    }
    ```
14. 在MVC中如何⽤表单认证？
    * 表单认证和ASP.NET的表单验证⼀样。第⼀步是设置认证模式为Forms。loginUrl是指向到controller，⽽
       不是⼀个⻚⾯。
    ```C#
     <authentication mode="Forms">
     <forms loginUrl="~/Home/Login" timeout="2880"/>
     </authentication>
    ```
    * 我们也需要创建⼀个controller，去验证⽤户。如果验证通过，需要设置cookies值。
    ```C#
    public ActionResult Login()
    {
        if ((Request.Form["txtUserName"] == "Shiv") &&
        (Request.Form["txtPassword"] == "Shiv@123"))
        {
            FormsAuthentication.SetAuthCookie("Shiv", true);
            return View("About");
        }
        else
        {
            return View("Index");
        }
    }
    ```
    * 其它需要验证的action都需要加⼀个 Authorize 属性，如果⽤户没权限将转向到登陆⻚⾯。
    ```C#
    [Authorize]
    PublicActionResult Default()
    {
        return View();
    }
    [Authorize]
    publicActionResult About()
    {
        return View();
    }
    ```
15. MVC有多少种不同类型的结果类型？
    * 注意： 很难去记住所有的12种类型。但是⼀些重要的你可以记住，例如： ActionResult ，  ViewResult
       ，和  JsonResult 。详情如下:
    * MVC中的12种结果类型，最主要的是ActionResult类，它是⼀个基础类，它有11个⼦类型，如下：
      * ViewResult  - 给响应流渲染指定的视图
      * PartialViewResult  - 给响应流渲染指定的局部视图
      * EmptyResult  - 返回空的响应结果。
      * RedirectResult  - 执⾏⼀个HTTP转向到指定的URL
      * RedirectToRouteResult  - 执⾏⼀个HTTP转向到⼀个URL，这个URL由基于路由数据的路由引擎来决定
      * JsonResult  - 序列化⼀个ViewData对像到JSON格式
      * JavaScriptResult  - 返回⼀段Javascript代码，它可以在客户端执⾏。
      * ContentResult  - 写内容到响应流，不需要视图⽀持。
      * FileContentResult  - 返回⼀个⽂件到客户端。
      * FileStreamResult  - 返回⼀个⽂件到客户端，它提供的是流。
      * FilePathResult  - 返回⼀个⽂件到客户端。
16. 什么是WebAPI?
    * HTTP是最常⽤的协议。过去的很多年，浏览器是我们使⽤HTTP⽅式公开数据的⾸选客户端。但是⽇新⽉
    异，客户端发展到多种形式。我们需要使⽤HTTP⽅式传递数据给不同的客户端，例如：移动⼿机、
    Javascript，Windows应⽤等等。
    * WebAPI是⼀个通过HTTP⽅式公开数据的技术，它跟随REST规则。
17. 什么是MVC中的打包也压缩?
    * 打包与压缩帮助我们减少⼀个⻚⾯的请求时间，从⽽提⾼⻚⾯执⾏性能。
    * 打包如何搞⾼性能？
    * 我们的项⽬总是需要CSS和脚本⽂件。打包帮助你合并多个Javascript和css⽂件到单个⽂件，从⽽最⼩化
    多个请求到⼀个请求。
    * 例如，包含下⾯的web请求到⼀个⻚。这个⻚⾯要求两个Javascript⽂件， Javascript1.js 和
    Javascript2.js 。
18. 简述Func与Action的区别?
    * Func是有返回值的委托，Action是没有返回值的委托。
19. 在项⽬中如何解决⾼并发问题？
    * 答案：尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交
    互，提⾼性能。
    * 优化数据库查询语句。
    * 优化数据库结构，多做索引，提⾼查询效率。
    * 统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。
    * 能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。
    * 解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。
20. MVC中还有哪些注释属性⽤来验证？
    * 如果你要去检查字符的⻓度，你可以使⽤ StringLength;
    ```C#
    [StringLength(160)]
    public string FirstName { get; set; }
    ```
    * 如果你想使⽤注册表达式，你可以使⽤ RegularExpression。
    `[RegularExpression(@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,
      4}")]public string Email { get; set; }`
    * 如果你想检查数字是否在⼀个范围内，你可以使⽤ Range。
    `[Range(10,25)]public int Age { get; set; }`
    * 有时你想⽐较两个字段的值，我们可以使⽤ Compare。
    ```C#
    public string Password { get; set; }
    [Compare("Password")]
    public string ConfirmPass { get; set; }
    ```
21. ActionResult 和 ViewResult有什么不同?
    * ActionResult 是⼀个抽象类，ViewResult衍⽣于 ActionResult 类。 ActionResult有⼏种衍⽣类，例
      如： ViewResult，JsonResult，FileStreamResult， 等等
    * ActionResult 可以⽤来开发多态和动态动象。所以如果你动态运⾏不同类型的视图，ActionResult 是最
      好的选择。例如下⾯的代码，你可以看⻅我们有⼀个DynamicView。基于标记（IsHtmlView），它会返回
      ViewResult 或 JsonResult。
22. MVC中如何执⾏打包？
    * 打开App_Start⽂件夹中的BundleConfig.cs
    * 在BundleConfig.cs中，添加你想打包的JS⽂件路径到打包集合。如下所示：
    ```C#
    bundles.Add(new ScriptBundle("~/Scripts/MyScripts").Include("~/Scripts/*.js"));
    ```
    * 下⾯是 BundleConfig.cs ⽂件的代码：
    ```C#
        public class BundleConfig
        {
            public static void RegisterBundles(BundleCollection bundles)
            {
                bundles.Add(new ScriptBundle("~/Scripts/MyScripts").Include("~/Scripts/*.js"));
                BundleTable.EnableOptimizations = true;
            }
        }
    ```
    * ⼀旦你合并了脚本到⼀个⽂件，你可以使⽤下⾯的代码去调⽤它：
    `<%= Scripts.Render("~/Scripts/MyScripts") %>`
23. MVC的路由选择是什么?
    * 路由选择功能帮你定义⼀个URL规则，映射URL到控制器。
24. 在哪⾥写路由映射表?
    * 在 “global.asax” ⽂件
25. 在MVC中提到Area的好处?
    * 在MVC中Area的好处如下：
      * 它允许我们将模型、视图和控制器组织成应⽤程序的单独功能部分，如管理、计费，客户⽀持和更多。
      * 很容易与另⼀个创建的其他区域集成。
      * 也很容易进⾏单元测试.
26. 你能解释⼀下MVC中的RenderBody和RenderPage吗？
    * RenderBody就像web表单中的ContentPlaceHolder。这将存在于布局⻚中，并将呈现⼦⻚/视图。布局
      ⻚将只有⼀个RenderBody（）⽅法。RenderPage也存在于布局⻚中，多个RenderPage（）可以存在于
      布局⻚中。
27. ASP.NET MVC的过滤器有哪些？
    * APS.NET MVC中（以下简称“MVC”）的每⼀个请求，都会分配给相应的控制器和对应的⾏为⽅法去处
    理，⽽在这些处理的前前后后如果想再加⼀些额外的逻辑处理。这时候就⽤到了过滤器。
    * MVC⽀持的过滤器类型有四种，分别是：Authorization(授权),Action（⾏为）,Result（结果）和
    Exception（异常）。
      * Authorization：此类型（或过滤器）⽤于限制进⼊控制器或控制器的某个⾏为⽅法。
      * Exception：⽤于指定⼀个⾏为，这个被指定的⾏为处理某个⾏为⽅法或某个控制器⾥⾯抛出的异常。
      * Action：⽤于进⼊⾏为之前或之后的处理。
      * Result：⽤于返回结果的之前或之后的处理。
## .NET/C# ⾯试题汇总系列：ASP.NET Core
1. 如何在controller中注⼊service?
   * 在config services⽅法中配置这个service。
   * 在controller的构造函数中，添加这个依赖注⼊。
2. 谈⼀谈对DDD的理解?
   * DDD，领域驱动设计。就是通过领域来指导软件设计，是⼀种⼗分抽象的软件设计思想，它主要分为战略
      设计和战术设计
   * 战略⽅⾯，通过事件⻛暴进⾏领域模型的划分，划分出核⼼域，⼦域，⽀撑域，定义通⽤语⾔，划分出界
     限上下⽂。
   * 在战术设计⽅⾯，ddd将架构分层，“松耦合，⾼内聚”是架构设计的整体思想。按照DDD思想，可以分为
     领域层，基础设施层，应⽤层，接⼝层。
   * 接⼝层为前端⽤户提供api接⼝。基础设施层可以放⼀些第三⽅的服务，数据库连接等内容。应⽤层是对领
     域服务的编排，是很薄的⼀层（⽬前我⾃⼰的架构，应⽤的是cqrs，所有的相关逻辑都是放在了应⽤层，
     ⽽领域层只是放了实体，因为暂时还不是特别理解领域层的服务和事件都应该写什么）。领域层包括实
     体，值对象，聚合根，领域服务，领域事件等内容。
3. ASP.NET Core ⽐ ASP.NET 更具优势的地⽅是什么？
    * 跨平台，ASP.NET Core 可以运⾏在 Windows 、Linux 和 MAC 系统上；
    * 对框架本安装没有依赖，所有依赖都跟程序本身在⼀起；
    * ASP.NET Core 处理请求的效率更⾼，进⽽可以处理更多的请求；
    * ASP.NET Core 具有更多的安装配置⽅法。
4. asp.net core 主要的特性有哪些？
   * 依赖注⼊。
   * ⽇志系统架构。
   * 引⼊了⼀个跨平台的⽹络服务器，kestrel。可以没有iis, apache和nginx就可以单独运⾏。
   * 可以使⽤命令⾏创建应⽤。
   * 使⽤AppSettings.json 来配置⼯程。
   * 使⽤start up来注册服务。
   * 更好的⽀持异步编程。
   * ⽀持web socket和signal IR。
   * 对于跨⽹站的请求的预防和保护机制。
5. ASP.NET Core Filter如何⽀持依赖注⼊?
   * 可以通过全局注册，⽀持依赖注⼊
   * 通过TypeFilter(typeof(Filter)) 标记在⽅法，标记在控制器
   * 通过ServiceType(typeof(Filter))标记在⽅法，标记在控制器，必须要注册Filter这类；
     * TypeFilter和ServiceType的本质是实现了⼀个IFilterFactory接⼝；
6. Asp.Net Core中有哪些异常处理的⽅案？
    1. 继承Controller，重写OnActionExecuted
        * 默认都会继承⼀个Controller类，重写OnActionExecuted，添加上异常处理即可。⼀般情况下我们会新建
        ⼀个BaseController, 让所有Controller继承BaseController。代码如下
            ```C#
            public class BaseController : Controller
            {
               public override void OnActionExecuted(ActionExecutedContext context)
              {
                  var exception = context.Exception;
                  if (exception != null)
                  {
                      context.ExceptionHandled = true;
                      context.Result = new ContentResult
                      {
                           Content = $"BaseController错误 : { exception.Message}"
                      };
                   }
                   base.OnActionExecuted(context);
               }
            }
            ```
    2. 使⽤ ActionFilterAttribute:
        * ActionFilterAttribute是⼀个特性，本身实现了 IActionFilter 及 IResultFilter , 所以不管是action⾥抛
             错，还是view⾥抛错，理论上都可以捕获。我们新建⼀个 ExceptionActionFilterAttribute, 重写
        OnActionExecuted及OnResultExecuted，添加上异常处理，完整代码如下:
          ```C#
          public class ExceptionActionFilterAttribute : ActionFilterAttribute
          {
              public override void OnActionExecuted(ActionExecutedContext context)
              {
                  var exception = context.Exception;
                  if (exception != null)
                  {
                        context.ExceptionHandled = true;
                        context.Result = new ContentResult
                        {
                            Content = $"错误 : { exception.Message }"
                        };
                    }
                base.OnActionExecuted(context);
              }

               public override void OnResultExecuted(ResultExecutedContext context)
               {
                   var exception = context.Exception;
                   if (exception != null)
                   {
                       context.ExceptionHandled = true;
                       context.HttpContext.Response.WriteAsync($"错误 : {exception.Message}");
                   }
                   base.OnResultExecuted(context);
               }
          }
          ```
        * 使⽤⽅式有两种，在controller⾥打上 [TypeFilter(typeof(ExceptionActionFilter)] 标签;在Startup⾥以filter⽅式全局注⼊。
        ```C# 
        services.AddControllersWithViews(options =>{options.Filters.Add<ExceptionActionFilterAttribute>();})
        ```
    3. 使⽤ IExceptionFilter
      1. 我们知道, Asp.Net Core提供了5类filter, IExceptionFilter是其中之⼀，顾名思义，这就是⽤来处理异常的。Asp.net Core中ExceptionFilterAttribute已经实现了IExceptionFilter，所以我们只需继承ExceptionFilterAttribute，重写其中⽅法即可。 同样新建CustomExceptionFilterAttribute继承ExceptionFilterAttribute，重写 OnException ，添加异常处理，完整代码如下：
      ```C#
      public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
      {
        public override void OnException(ExceptionContext context)
        {
            context.ExceptionHandled = true;
            context.HttpContext.Response.WriteAsync($"CustomExceptionFilterAttribute错误:{context.Exception.Message}");
            base.OnException(context);
        }
      }
      ```
    4. 使⽤ExceptionHandler.
    * 在 startup ⾥，vs新建的项⽬会默认加上.
    ```C#
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/Home/Error");
    }
    ```
    5. ⾃定义Middleare处理
      * 通过middleware全局处理。
        ```C#
        public class ErrorHandlingMiddleware
        {
            private readonly RequestDelegate next;
            public ErrorHandlingMiddleware(RequestDelegate next)
            {
                this.next = next;
            }
            public async Task Invoke(HttpContext context)
            {
                try
                {
                    await next(context);
                }
                catch (System.Exception ex)
                {
                 //处理异常
                }
            }
        }
        ``` 
7. 介绍ASP.NET Core中服务的⽣命周期？
   *  ASP.NET Core⽀持依赖注⼊软件设计模式，它允许在不同的组件中注⼊我们的服务并且控制服务的初始化。有些服务可以在短时间内初始化，并且只能在某个特别的组件，以及请求中才能⽤到；⽽还有⼀些服务，仅仅只⽤初始化⼀次，就可以在整个应⽤程序中使⽤。
   *  Singleton  --单例模式：
      *  只有⼀个服务的实例被创建，这个实例，存储在内存中，可以在整个应⽤程序中使⽤。我们可以对⼀些初始化代价⽐较⼤的服务，使⽤Singleton模式。在代码中可以这样：`services.AddSingleton<IProductService, ProductService>();`
   * Scoped  --作⽤域
     * 这种模式下，将会为每⼀个请求，都创建⼀个服务的实例。所有同⼀个请求中的中间件、MVC控制器，等等，都会得到⼀个相同的服务实例。Entity Framework Context就是⼀个Scoped服务最好的参考例⼦。我们可以通过使⽤AddScoped⽅法来使⽤Scoped模式:`services.AddScoped<IProductService, ProductService>();`
   * Transient  --短暂的、瞬变的
     * Transient模式下，服务每次被请求的时候，都会创建⼀个服务实例，这种模式特别适合轻量级、⽆状态的服务。我们可以使⽤AddTransient⽅法，来注⼊服务：`services.AddTransient<IProductService, ProductService>();`
8. 什么是依赖注⼊？
   *  依赖注⼊是⼀个过程，就是当⼀个类需要调⽤另⼀个类来完成某项任务的时候，在调⽤类⾥⾯不要去new被调⽤的类的对象，⽽是通过注⼊的⽅式来获取这样⼀个对象。具体的实现就是在调⽤类⾥⾯有⼀个被调⽤类的接⼝，然后通过调⽤接⼝的函数来完成任务。⽐如A调⽤B，⽽B实现了接⼝C，那么在A⾥⾯⽤C定义⼀个变量D，这个变量的实例不在A⾥⾯创建，⽽是通过A的上下⽂来获取。这样做的好处就是将类A和B分开了，他们之间靠接⼝C来联系，从⽽实现对接⼝编程。
9. 依赖注⼊有哪⼏种⽅式？
   * setter注⼊: 就是在类A⾥⾯定义⼀个C接⼝的属性D，在A的上下⽂通过B实例化⼀个对象，然后将这个对象赋值给属性D。主要就是set 与 get
   * 构造函数注⼊:就是在创建A的对象的时候，通过参数将B的对象传⼊到A中。还有常⽤的注⼊⽅式就是⼯⼚模式的应⽤了，这些都可以将B的实例化放到A外⾯，从⽽让A和B没有关系。还有⼀个接⼝注⼊，就是在客户类（A）的接⼝中有⼀个服务类(B)的属性。在实例化了这个接⼝的⼦类后，对这个属性赋值，这和setter注⼊⼀样。
   * 接⼝注⼊:相⽐构造函数注⼊和属性注⼊，接⼝注⼊显得有些复杂，使⽤也不常⻅。具体思路是先定义⼀个接⼝，包含⼀个设置依赖的⽅法。然后依赖类，继承并实现这个接⼝。
10. 控制反转是什么？
    * 控制反转（Inversion of Control，缩写为IoC），是⾯向对象编程中的⼀种设计原则，可以⽤来减低计算机代码之间的耦合度。其中最常⻅的⽅式叫做依赖注⼊（Dependency Injection，简称DI），还有⼀种⽅式叫“依赖查找”（Dependency Lookup）。
    * 通过控制反转，对象在被创建的时候，由⼀个调控系统内所有对象的外界实体将其所依赖的对象的引⽤传递给它。也可以说，依赖被注⼊到对象中。
11. 依赖注⼊有哪些著名的框架？
    * Unity、autofac、http://spring.net、MEF、Injection、Asp.Net Core的ServiceCollection。
12. 介绍⼀些ABP.NEXT？ 
    * ASP.NET Boilerplate是.Net平台⾮常优秀的⼀个开源Web应⽤程序框架
    * ASP.NET Core引⼊了许多内置解决⽅案（扩展库），⽤于依赖注⼊，⽇志记录，缓存，本地化，配置等。它们实际上独⽴于ASP.NET Core，可⽤于任何类型的应⽤程序。
13. 什么是dot net core的startup class ?
    * Startup class是dot net core应⽤的⼊⼝。所有的dot net core应⽤必须有这个class。这个类⽤来配置应⽤。这个类的调⽤是在program main函数⾥⾯进⾏配置的。类的名字可以⾃⼰定义。
14. startup class的configure⽅法有什么作⽤？
    这个⽅法来定义整个应⽤如何响应HTTP请求。它有⼏个⽐较重要的参数，application builder，Hostingenvironment, logo factory， 在这⾥我们可以配置⼀些中间件⽤来处理路径，验证和session等等。
15. 什么是中间件（Middleware）？
    * 中间件是组装到应⽤程序管道中以处理请求和响应的软件。 每个组件：
        * 选择是否将请求传递给管道中的下⼀个组件。
        * 可以在调⽤管道中的下⼀个组件之前和之后执⾏⼯作。
        * 请求委托（Request delegates）⽤于构建请求管道，处理每个HTTP请求。
        * 请求委托使⽤Run，Map和Use扩展⽅法进⾏配置。单独的请求委托可以以内联匿名⽅法（称为内联中间件）指定，或者可以在可重⽤的类中定义它。这些可重⽤的类和内联匿名⽅法是中间件或中间件组件。请求流程中的每个中间件组件都负责调⽤流⽔线中的下⼀个组件，如果适当，则负责链接短路。
16. 中间件的使⽤场景有哪些？
    * 身份验证，Session存储，⽇志记录等。其实我们的Asp.net core项⽬中本身已经包含了很多个中间件。⽐如 身份认证中间件 UseAuthorization()等系列
17. 列举官⽅常⽤的中间件？
    * 异常/错误处理 当应⽤在开发环境中运⾏时： 开发⼈员异常⻚中间件 (UseDeveloperExceptionPage) 报告应⽤运⾏时错误。 数据库错误⻚中间件报告数据库运⾏时错误。 当应⽤在⽣产环境中运⾏时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议(HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。
    * HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。
    * 静态⽂件中间件 (UseStaticFiles) 返回静态⽂件，并简化进⼀步请求处理。
    * Cookie 策略中间件 (UseCookiePolicy) 使应⽤符合欧盟⼀般数据保护条例 (GDPR) 规定。⽤于路由请求的路由中间件 (UseRouting)。
    * 身份验证中间件 (UseAuthentication) 尝试对⽤户进⾏身份验证，然后才会允许⽤户访问安全资源。
    * ⽤于授权⽤户访问安全资源的授权中间件 (UseAuthorization)。
    * 会话中间件 (UseSession) 建⽴和维护会话状态。 如果应⽤使⽤会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调⽤会话中间件。
    * ⽤于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有MapRazorPages 的UseEndpoints）。
18. 中间件的执⾏顺序？
    * 异常/错误处理
    * HTTP 严格传输安全协议
    * HTTPS 重定向
    * 静态⽂件服务器
    * Cookie 策略实施
    * 身份验证
    * 会话
    * MVC
19. application builder的use和run⽅法有什么区别？
    * 这两个⽅法都在start up class的configure⽅法⾥⾯调⽤。都是⽤来向应⽤请求管道⾥⾯添加中间件的。Use⽅法可以调⽤下⼀个中间件的添加，⽽run不会
20. dot net core 管道⾥⾯的map拓展有什么作⽤?
    * 可以针对不同的路径添加不同的中间件。
    ```C#
    public void Configure(IApplicationBuilder app)
    {
        app.Map("/path1", Middleware1);
        app.Map("/path2", Middleware2);
    }
    ```
21. dot net core⾥⾯的路径是如何处理的？
    * 路径处理是⽤来为进⼊的请求寻找处理函数的机制。所有的路径在函数运⾏开始时进⾏注册。
    * 主要有两种路径处理⽅式， 常规路径处理和属性路径处理。常规路径处理就是⽤MapRoute的⽅式设定调⽤路径，属性路径处理是指在调⽤函数的上⽅设定⼀个路径属性。
22. dot net core⼯程⾥⾯有哪些常⻅的⼯程⽂件 ?
    * global, launch setting，app settings，bundle config，bower, package。
23. 依赖注⼊实现原理？
    * 实现DI，核⼼在于依赖注⼊容器IContainer，该容器具有以下功能
      * (容器）保存可⽤服务的集合 // 要⽤的特定对象、特定类、接⼝服务
      * （注册）提供⼀种⽅式将各种部件与他们依赖的服务绑定到⼀起；// Add...函数或
      containerBuilder.Register函数，
      * （解析点）为应⽤程序提供⼀种⽅式来请求已配置的对象： 构造函数注⼊、属性注⼊.
      运⾏时，框架会⼀层层通过反射构造实例，最终得到完整对象。
24. ASP.NET Core项⽬如何设置IP地址和端⼝号？
    * 可以使⽤Properties⽂件夹下的launchSettings配置⽂件来配置不同的启动⽅式的时候，分别配置IP和端⼝号。
## .NET/C#⾯试题汇总系列：ADO.NET、XML、HTTP、AJAX、WebService
1. .NET和C#有什么区别?
   * .NET⼀般指 .NET FrameWork框架，它是⼀种平台，⼀种技术。
   * C#是⼀种编程语⾔，可以基于.NET平台的应⽤。
2. 请编程遍历⻚⾯上所有TextBox控件并给它赋值为string.Empty？
   ```c#
    foreach (System.Windows.Forms.Control control in this.Controls)
    {
        if (control is System.Windows.Forms.TextBox)
        {
            System.Windows.Forms.TextBox tb = (System.Windows.Forms.TextBo
            control ;
            tb.Text = String.Empty;
        }
    }
    ```
3. CTS、CLS、CLR分别作何解释?
    * CTS：通⽤语⾔系统。CLS：通⽤语⾔规范。CLR：公共语⾔运⾏库
4. 什么是受管制的代码?
    * unsafe：⾮托管代码。不经过CLR运⾏。 
5. 什么是强类型系统？
    * RTTI：类型识别系统。
6. 列举ASP.NET⻚⾯之间传递值的⼏种⽅式。
    * 使⽤QueryString, 如....?id=1; response. Redirect()....
    * 使⽤Session变量
    * 使⽤Server.Transfer
7. 什么是Code-Behind技术？
    * 代码后植
8. 在.net中，配件的意思是？
    * 程序集。（中间语⾔，源数据，资源，装配清单）
9. .netRemoting 的⼯作原理是什么
    * 服务器端向客户端发送⼀个进程编号，⼀个程序域编号，以确定对象的位置
10. 分析以下代码，i=? j=?
    ```C#
    stringstrTmp = "abcdefg某某某";
    inti= System.Text.Encoding.Default.GetBytes(strTmp).Length;
    intj= strTmp.Length;
    //i=13.j=10
    ```
11. 是否可以继承String类?
    * String类是final类故不可以继承。
12. Session有什么重⼤BUG，微软提出了什么⽅法加以解决?
    * 是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以⽤Sate server或SQL Server数据库的⽅式存储Session不过这种⽅式⽐较慢，⽽且⽆法捕获Session的END事件。
13. DataReader与Dataset有什么区别？
    * ⼀个是只能向前的只读游标，⼀个是内存中虚拟的数据库。
14. 什么是XML？
    * XML即可扩展标记语⾔。eXtensible Markup Language.标记是指计算机所能 理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的⽂章等。如何定义这些标记，即可以选择国际通⽤的标记语⾔，⽐如HTML，也可以使⽤象XML这样由相关⼈⼠⾃由决定的标记语⾔，这就是语⾔的可扩展性。XML是从SGML中简化修改出来的。它主要⽤到的有XML、XSL和XPath等。
15. 什么是WebService？UDDI？
    * Web Service便是基于⽹络的、分布式的模块化组件，它执⾏特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进⾏互操作。UDDI的⽬的是为电⼦商务建⽴标准；UDDI是⼀套基于Web的、分布式的、为WebService提供的、信息注册中⼼的实现标准规范，同时也包含⼀组使企业能将⾃身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。
16. 什么是ASP.net中的⽤户控件？
    * ⽤户控件⼀般⽤在内容多为静态,或者少许会改变的情况下..⽤的⽐较⼤..类似ASP中的include..但是功能要强⼤的多。
17. 列举⼀下你所了解的XML技术及其应⽤
    * xml⽤于配置,⽤于保存静态数据类型.接触XML最多的是web Services..和config
18. 什么是code-Behind技术？
    * ASPX,RESX和CS三个后缀的⽂件，这个就是代码分离.实现了HTML代码和服务器代码分离.⽅便代码编写和整理。
19. 什么是SOAP,有哪些应⽤？
    * simple object access protocal,简单对象接受协议.以xml为基本编码结构,建⽴在已有通信协议上(如http,不过据说ms在搞最底层的架构在tcp/ip上的soap)的⼀种规范WebService使⽤的协议。
20. C#中 property 与 attribute的区别，他们各有什么⽤处，这种机制的好处在哪⾥？
    * ⼀个是属性，⽤于存取类的字段，⼀个是特性，⽤来标识类，⽅法等的附加性质。
21. XML与 HTML 的主要区别? 
    1. XML是区分⼤⼩写字⺟的，HTML不区分。
    2. 在HTML中，如果上下⽂清楚地显示出段落或者列表键在何处结尾，那么你可以省略
    3. 在XML中，拥有单个标记⽽没有匹配的结束标记的元素必须⽤⼀个 / 字符作为结尾。这样分析器就知道不⽤查找结束标记了。
    4. 在XML中，属性值必须分装在引号中。在HTML中，引号是可⽤可不⽤的。
    5. 在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。
22. 在.Net中，类System.Web.UI.Page 可以被继承么?
    * 可以。
23. 在.net（C# or vb.net）中，Appplication.Exit 还是 Form.Close有什么不同？
    * ⼀个是退出整个应⽤程序，⼀个是关闭其中⼀个form。
24. <%# %> 和 <% %> 有什么区别？
    * <%# %>表示绑定的数据源
    * <%%>是服务器端代码块
25. ADO.NET中读写数据库需要使⽤哪些对象？作⽤是什么？
    * Connection连接对象，Command执⾏命令和存储过程，DataReader向前只读的数据流，DataAdapter适配器，⽀持增删查询，DataSet数据级对象，相当与内存⾥的⼀张或多张表。
26. 什么是SQL注⼊，应该如何防⽌?
    * 利⽤sql关键字对⽹站进⾏攻击,⽤参数化的SQL就可以避免SQL注⼊!
27. 详细描述三层架构开发模式以及三层架构的好处?
    * 数据访问层，业务层，表示层。
    * 数据访问层（DAL），主要是存放对数据类的访问，即对数据库的添加、删除、修改、更新等基本操作
    * 业务逻辑层（BLL）对传送数据进⾏逻辑判断分折，并进⾏传送正确的值。　　　　　
    * 表示层为了与⽤户交互例如⽤户添加表单。
    * 优点： 分⼯明确，条理清晰，易于调试，⽽且具有可扩展性。
28. 说出⼀些常⽤的类、接⼝，请各举5个?
    * 要让⼈家感觉你对.Net开发很熟，所以，不能仅仅只列谁都能想到的那些东⻄，要多列你在做项⽬中涉及的那些东⻄。就写你最近写的那些程序中涉及的那些类。
    * 常⽤的类：StreamReader、WebClient、Dictionary<K,V>、StringBuilder、SqlConnection、FileStream、File、Regex、List
    * 常⽤的接⼝：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、  IDictionary
29. 不是说字符串是不可变的吗？string s="abc";s="123"不就是变了吗？
    * String是不可变的在这段代码中，s原先指向⼀个String对象，内容是 "abc"，然后我们将s指向"123"，
    那么s所指向的那个对象是否发⽣了改变呢？答案是没有。这时，s不指向原来那个对象了，⽽指向了另⼀个
    String对象，内容为"123"，原来那个对象还存在于内存之中，只是s这个引⽤变量不再指向它了。
30. post、get的区别?
    * get的参数会显示在浏览器地址栏中，⽽post的参数不会显示在浏览器地址栏中；
    * 使⽤post提交的⻚⾯在点击【刷新】按钮的时候浏览器⼀般会提示“是否重新提交”，⽽get则不会；
    * ⽤get的⻚⾯可以被搜索引擎抓取，⽽⽤post的则不可以；
    * ⽤post可以提交的数据量⾮常⼤，⽽⽤get可以提交的数据量则⾮常⼩(2k)，受限于⽹⻚地址的⻓度。
    * ⽤post可以进⾏⽂件的提交，⽽⽤get则不可以。
31. http 响应码 301 和 302 代表的是什么？有什么区别？
    * 301：永久重定向；302：暂时重定向。
    * 它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为⽹络拦截的⻛险。
32. Server.Transfer和Response.Redirect的区别是什么？
    * Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。
    * Server.Transfer是服务器请求资源，服务器直接访问⽬标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪⼉来的，所以它的地址栏中还是原来的地址。 这个过程中浏览器和Web服务器之间经过了⼀次交互。
    * Response.Redirect就是服务端根据逻辑,发送⼀个状态码,告诉浏览器重新去请求那个地址，⼀般来说浏览器会⽤刚才请求的所有参数重新请求。这个过程中浏览器和Web服务器之间经过了两次交互。
    * Server.Transfer不可以转向外部⽹站，⽽Response.Redirect可以。
    * Server.Execute效果和Server.Transfer类似，但是是把执⾏的结果嵌⼊当前⻚⾯。
33. 什么是 XSS 攻击，如何避免
    * XSS 攻击：即跨站脚本攻击，它是 Web 程序中常⻅的漏洞。原理是攻击者往 Web ⻚⾯⾥插⼊恶意的脚
      本代码（css 代码、Javascript 代码等），当⽤户浏览该⻚⾯时，嵌⼊其中的脚本代码会被执⾏，从⽽达
      到恶意攻击⽤户的⽬的，如盗取⽤户 cookie、破坏⻚⾯结构、重定向到其他⽹站等。 预防 XSS 的核⼼是
      必须对输⼊的数据做过滤处理。
34. HTTP fetch发送2次请求的原因？
    * fetch发送post请求的时候，总是发送2次，第⼀次状态码是204，第⼆次才成功？
    * 原因很简单，因为你⽤fetch的post请求的时候，导致fetch 第⼀次发送了⼀个Options请求，询问服务器
    是否⽀持修改的请求头，如果服务器⽀持，则在第⼆次中发送真正的请求。
35. HTTP常⻅的的头部有哪些？
    * 可以将http⾸部分为通⽤⾸部，请求⾸部，响应⾸部，实体⾸部
      * 通⽤⾸部表示⼀些通⽤信息，⽐如date表示报⽂创建时间，
      * 请求⾸部就是请求报⽂中独有的，如cookie，和缓存相关的如if-Modified-Since
      * 响应⾸部就是响应报⽂中独有的，如set-cookie，和重定向相关的location，
      * 实体⾸部⽤来描述实体部分，如allow⽤来描述可执⾏的请求⽅法，content-type描述主题类型，
      content-Encoding描述主体的编码⽅式
36. 什么是 CSRF 攻击，如何避免？
    * CSRF：Cross-Site Request Forgery（中⽂：跨站请求伪造），可以理解为攻击者盗⽤了你的身份，以
      你的名义发送恶意请求，⽐如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。 防御⼿段：
      验证请求来源地址； 关键操作添加验证码； 在请求地址添加 token 并验证。
37. HTTP 状态码 304 的含义？什么时候⽤304？
    * 304：如果客户端发送了⼀个带条件的GET 请求且该请求已被允许，⽽⽂档的内容（⾃上次访问以来或者
      根据请求的条件）并没有改变，则服务器应当返回这个304状态码。
38. ASP.NET和ASP有什么区别?
    * ASP.NET的脚本是⾬HTML分离的，代码被编译成了DLL, DLL可以在server端执⾏。
    * ASP的脚本是与HTML在⼀起的，每次都会进⾏解释执⾏。
39. 简述 Application，session，cookie，cache，viewState 的概念，以及相互之间的区
别?
    * Application 任意⼤⼩ 整个应⽤程序的⽣命期 所有⽤户 服务器端
    * Seccion ⼩量，简单的数据 ⽤户活动时间+ 单个⽤户 服务器端⼀段延迟时间（⼀般为20分钟）
    * Cookie ⼩量，简单的数据 可以根据需要设定 单个⽤户 客户端
    * ViewState ⼩量，简单的数据 ⼀个Web⻚⾯的⽣命期 单个⽤户 客户端
    * Cache 任意⼤⼩ 可以根据需要设定 所有⽤户 服务器端
40. ASP.NET中的六⼤对象有哪些？
    1. Response
    2. Request
    3. Server
    4. Application
    5. Session
    6. Cookie
41. 在c#中，反射是什么？处理反射相关的namespace是什么？
    * 反射（Reflection）是.NET中的重要机制，通过放射，可以在运⾏时获 得.NET 中每⼀个类型（包括类、
      结构、委托、接⼝和枚举等）的成员，包括⽅法、属性、事件，以及构造函数等。还可以获得每个成员的
      名称、限定符和参数等。
42. ExecuteScalar 和 ExecuteNonQuery 的区别?
    * ExecuteNonQuery：返回受影响的⾏数。
    * ExecuteScalar：返回结果集的第⼀⾏第⼀列，忽略其他⾏
43. 说明C#中的⽅法声明参数关键字params，ref，out的意义及⽤法?
    1. params关键字，官⽅给出的解释为⽤于⽅法参数⻓度不定的情况。有时候不能确定⼀个⽅法的⽅法参
    数到底有多少个，可以使⽤params关键字来解决问题
    2. ref关键字：使⽤引⽤类型参数，在⽅法中对参数所做的任何更改都将反应在该变量中 
    3. out 关键字：out 与ref相似但是out ⽆需进⾏初始化
44. 简单描述Ihtttphandler和Ihttpmodule的区别和各⾃的作⽤？
    1. 先后次序.先IHttpModule,后IHttpHandler. 注:Module要看你响应了哪个事件，⼀些事件是在Handler之
    前运⾏的，⼀些是在Handler之后运⾏的
    2. 对请求的处理上:
    IHttpModule 是属于⼤⼩通吃类型,⽆论客户端请求的是什么⽂件,都会调⽤到它;例如 aspx,rar,html的请
    求.
    IHttpHandler则属于挑⻝类型,只有ASP.net注册过的⽂件类型(例如aspx,asmx等等) 才会轮到调⽤它.
    3. IHttpHandler按照你的请求 ⽣成响应的内容，IHttpModule对请求进⾏预处理，如验证、修改、过滤等
    等，同时也可以对响应进⾏处理
45. 什么是托管代码、⾮托管代码托管代码 (managed code)
    * 由公共语⾔运⾏库环境（⽽不是直接由操作系统）执⾏的代码。托管代码应⽤程序可以获得公共语⾔运⾏
    库服务，例如⾃动垃圾回收、运⾏库类型检查和安全⽀持等。这些服务帮助提供独⽴于平台和语⾔的、统
    ⼀的托管代码应⽤程序⾏为。
    * ⾮托管代码 (unmanaged code)
    在公共语⾔运⾏库环境的外部，由操作系统直接执⾏的代码。⾮托管代码必须提供⾃⼰的垃圾回收、类型
    检查、安全⽀持等服务；它与托管代码不同，后者从公共语⾔运⾏库中获得这些服务。
46. GC是什么? 为什么要有GC?
    1. GC是垃圾收集器。程序员不⽤担⼼内存管理，因为垃圾收集器会⾃动进⾏管理.
    2. NET的GC机制有这样两个问题：⾸先，GC并不是能释放所有的资源。它不能⾃动释放⾮托管资源。
    * GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。
    * GC就是对“不可达“的对象进⾏回收，释放内存。
47. 数组、链表、哈希、队列、栈数据结构特点，各⾃优点和缺点?
    * 数组(Array)：
      * 优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复；
      * 缺点：在中间部位添加、删除⽐较复杂，⼤⼩固定，只能存储⼀种类型的数据；
      * 如果应⽤需要快速访问数据，很少插⼊和删除元素，就应该⽤数组。
    * 链表(LinkedList)：
      * 优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了；
      * 缺点：查询慢，如果要访问链表中⼀个元素，就需要从第⼀个元素开始查找；
      * 如果应⽤需要经常插⼊和删除元素，就应该⽤链表。
    * 栈(Stack)：
      * 优点：提供后进先出的存储⽅式，添加速度快，允许重复；
      * 缺点：只能在⼀头操作数据，存取其他项很慢；
    * 队列(Queue)：
      * 优点：提供先进先出的存储⽅式，添加速度快，允许重复；
      * 缺点：只能在⼀头添加，另⼀头获取，存取其他项很慢；
    * 哈希(Hash)：
      * 特点：散列表，不允许重复；
      * 优点：如果关键字已知则存取速度极快；
      * 缺点：如果不知道关键字则存取很慢，对存储空间使⽤不充分
48. 应⽤程序池集成模式和经典模式的区别?
    * 如果托管应⽤程序在采⽤集成模式的应⽤程序池中知运⾏，服务器将使⽤ IIS 和 ASP.NET 的集成请求处
      理管道来处理请求。
    * 如果托管应⽤程序在采⽤经典模式的应⽤程序池中运⾏，服务器会继续通过 Aspnet_isapi.dll
      路由托管代码请求，其处理请求的⽅式就像应⽤程序在 IIS 6.0 中运⾏⼀样。
49. AJAX的底层实现原理?
    * Ajax核⼼—-----XMLHttpRequest
      * 上⾯我们⼤概感受了⼀下Ajax的过程，我们发现发送异步请求才是核⼼，事实上它就是
      XMLHttpRequest，整个Ajax之所以能完成异步请求完全是因为这个对应可以发送异步请求的缘故。
      ⽽且我们⼜发现上⾯那个事件就是整个处理过程的核⼼，可以根据不同状态执⾏不同操作，其实它就是
      XMLHttpRequest的⽅法onreadystatechange，它在每次状态发⽣改变时都会触发。那么是谁取得的返
      回信息呢？它就是XMLHttpRequest的另⼀个⽅法responseText（当然还有responseXML）。
      我们还没有说发送给谁以及执⾏发送操作，这两个就是XMLHttpRequest的open和send⽅法。Y(o)Y，其
      他的当然还有了，我们直接列出来吧：
    * XMLHttpRequest对象属性
      * readyState：请求状态，开始请求时值为0直到请求完成这个值增⻓到4
      * responseText：⽬前为⽌接收到的响应体,readyState<3此属性为空字符串，=3为当前响应体，=4则为
      完整响应体
      * responseXML：服务器端相应，解析为xml并作为Document对象返回
      * status：服务器端返回的状态码，=200成功，=404表示“Not Found”
      * statusText：⽤名称表示的服务器端返回状态，对于“OK”为200，“Not Found”为400
      ⽅法
      * setRequestHeader()：向⼀个打开但是未发⽣的请求设置头信息
      * open()：初始化请求参数但是不发送
      * send()：发送Http请求
      * abort()：取消当前相应
      * getAllResponseHeaders()：把http相应头作为未解析的字符串返回
      * getResponseHeader()：返回http相应头的值
50. 能够将⾮静态的⽅法覆写成静态⽅法吗？
    * 答：不能，覆写⽅法的签名必须与被覆写⽅法的签名保持⼀致，除了将virtual改为override。
51. DateTime.Parse(myString); 这⾏代码有什么问题？
    * 有问题，当myString不能满⾜时间格式要求的时候，会引发异常，建议使⽤DateTime.TryParse();
52. Server.UrlEncode、HttpUtility.UrlDecode的区别?
    * Server.UrlEncode的编码⽅式是按照本地程序设置的编码⽅式进⾏编码的，⽽HttpUtility.UrlEncode是默
      认的按照.net的utf-8格式进⾏编码的。
53. 何时创建连接池？
    * 当第⼀个连接请求到来时创建连接池；连接池的建⽴由数据库连接的连接字符创来决定。每⼀个连接池都
      与⼀个不同的连接字符串相关。当⼀个新的连接请求到来时如果连接字符串和连接池使⽤的字符串相同，
      就从连接池取出⼀个连接；如果不相同，就新建⼀个连接池。
54. 何时关闭连接池？
    * 当连接池中的所有连接都已经关闭时关闭连接池。
55. 当连接池中的连接都已经⽤完，⽽有新的连接请求到来时会发⽣什么？
    * 当连接池已经达到它的最⼤连接数⽬时，有新的连接请求到来时，新的连接请求将放置到连接队列中。当
      有连接释放给连接池时，连接池将新释放的连接分配给在队列中排队的连接请求。你可以调⽤close和
      dispose将连接归还给连接池。
56. 如何允许连接池？
    * 对于.NET应⽤程序⽽⾔，默认为允许连接池。（这意味着你可以不必为这件事情做任何的事情）当然，如
      果你可以在SQLConnection对象的连接字符串中加进Pooling=true;确保你的应⽤程序允许连接池的使
      ⽤。
57. 应该如何禁⽌连接池?
    * ADO.NET默认为允许数据库连接池，如果你希望禁⽌连接池，可以使⽤如下的⽅式：
      1. 使⽤SQLConnection对象时，往连接字符串加⼊如下内容：Pooling=False;
      2. 使⽤OLEDBConnection对象时，往连接字符串加⼊如下内容：OLE DB Services=-4;
58. 私有程序集与共享程序集有什么区别？
    * ⼀个私有程序集通常为单个应⽤程序所使⽤，并且存储于这个应⽤程序所在的⽬录之中，或此⽬录下⾯的
      ⼀个⼦⽬录中。共享程序集通常存储在全局程序集缓存（Global Assembly Cache）之中，这是⼀个由.NET运⾏
    时所维 护的程序集仓库。共享程序集通常是对许多应⽤程序都有⽤的代码库，⽐如.NET Framework类。
59. 请解释web.config⽂件中的重要节点？
    * appSettings包含⾃定义应⽤程序设置。
    * system.web 系统配置；
    * compilation动态调试编译设置；
    * customErrors⾃定义错误信息设置；
    * authentication身份验证,此节设置应⽤程序的身份验证策略。
    * authorization授权, 此节设置应⽤程序的授权策略。
60. 什么是viewstate，能否禁⽤？是否所⽤控件都可以禁⽤?
    * Viewstate是保存状态的⼀种机制，EnableViewState属性设置为false即可禁⽤
61. 什么是Windows服务，它的⽣命周期与标准的EXE程序有什么不同?
    * Windows服务是运⾏在windows后台指定⽤户下（默认System）的应⽤程序，它没有标准的UI界⾯，想
    ⽐标准的EXE程序，Windows服务是在服务开始的时候创建，⽽在服务结束的时候销毁，⽽且可以设置服务是否
    与操作系统⼀起启动，⼀起关闭。它⽀持三种⽅式：１）⾃动⽅式 2）⼿动⽅式 ３）禁⽤ 。⾃动⽅式的时
    候，windows服务将在OS启动后⾃动启动运⾏，⽽⼿动⽅式则必须⼿⼯启动服务，禁⽤的情况下服务将不
    能被启动。另外标准的EXE默认使⽤的当前登录的⽤户，⽽windows服务则默认使⽤System⽤户，这在对系统
    资源访问的时候特别需要注意。
62. 什么是GAC？它解决了什么问题?
    * Gloal Assembly Cache，全局应⽤程序集缓存。它解决了⼏个程序共享某⼀个程序集的问题。不必再将
      那个被共享的程序集拷⻉到应⽤程序⽬录了，其实这道理很简单，.net应⽤程序在加载的时候，会⾸先查看全局应
      ⽤程序集缓存，如果有就可以直接使⽤，没有再到应⽤程序⽬录进⾏查找。
63. 数据访问通过aspx⻚⾯和DB层会很慢，有什么解决⽅法?
    * （1）浏览器使⽤缓存；
    * （2）使⽤压缩的JS和CSS
    * （3）减少发送HTTP请求的次数；
    * （4）后台，对于⼀些不经常变化的数据进⾏Cache；
    * （5）对可能的低效率的SQL语句进⾏优化；
    * （6）进⾏服务器负载均衡；

## .NET/C#⾯试题汇总系列：常⻅的算法
1. 求质数
   * 质数也成为素数，质数就是这个数除了1和他本身两个因数以外，没有其他因数的数，叫做质数，和他相反
   的是合数，就是除了1和他本身两个因数以外，还友其他因数的数叫做合数。
   ```C#
   //以下为函数部分
        static void cal(long x)
        {
            long sum = 1;
            byte row = 1;
            Console.Write("\n");
            for (long a = 3; a < x + 1; a++)
            {
                bool flag = true;
                for (long b = 2; b < (a / 2) + 1; b++)
                {
                    if (a % b != 0) continue;
                    flag = false;
                    break;
                }
                if (flag)
                {
                    if (row == 10) { Console.WriteLine(); row = 0; }
                    if (sum == 1) Console.Write("{0,7}", 2);
                    Console.Write("{0,7}", a);
                    sum++; row++;
                }
            }
            Console.WriteLine("\n\n{0} 以内共有 {1} 个质数\n", x, sum);
        }
   ```
2. ⼀列数1，1，2，3，5，........求第30个数.
    ```C#
        public static int Foo(int i)
        {
            if (i <= 0)
                return 0;
            else if (i > 0 && i <= 2)
                return 1;
            else
                return Foo(i - 1) + Foo(i - 2);
        }
    ```
3. 冒泡排序
    ```C#
        //冒泡排序类
        public class sorter
        {
            public void Sort(int[] list)
            {
                int i, j, temp;
                bool done = false;
                j = 1;
                while ((j < list.Length) && (!done))
                {
                    done = true;
                    for (i = 0; i < list.Length - j; i++)
                    {
                        if (list[i] > list[i + 1])
                        {
                            done = false;
                            temp = list[i];
                            list[i] = list[i + 1];
                            list[i + 1] = temp;
                        }
                    }
                    j++;
                }
            }
        }
    ```
4. 请编写⼀个函数，能够计算10以内数的阶乘，尽量采⽤递归算法。（10!=3628800）。
    ```C#
        public int jiecheng(int n)
        {
            if (n == 1)
                return 1;
            else if (n == 2)
                return 2;
            else
                return n * jiecheng(n - 1);
        }
    ```
5. 请编程实现此⽅法。将输⼊的整型数组，合并转换为逗号分隔的字符串。
    * 例如输⼊参数为整型数组{9，7，2}，那么输出结果为字符串"9,7,2"。
    ```C#
    private static string Combine(int[] data)
        {
            string str = "";
            foreach (int s in data)
            {
                str += s.ToString() + ",";
            }
            return str;
        }
    ```
6. 产⽣⼀个int数组，⻓度为100，并向其中随机插⼊1-100，并且不能重复。
    ```C#
    //产⽣⼀个int数组，⻓度为100，并向其中随机插⼊1-100，并且不能重复。
    int[] arr = new int[100];
    ArrayList myList = new ArrayList();
    Random rad = new Random();
    while (myList.Count < 100)
    {
        int num = rad.Next(1, 101);
        if (!myList.Contains(num))
        {
            myList.Add(num);
        }
    }
    for (int i = 0; i < 100; i++)
    {
        arr[i] = (int)myList[i];
    }
    for (int i = 0; i < arr.Length; i++)
    {
        Console.Write(arr[i] + ",");
    }
    Console.ReadKey();
    ```
7. 请将字符串"I am a student"按单词逆序输出 如"student a am I"
    ```C#
    string S = "I am a student";
    char[] C = new char[] { ' ' };
    string[] n = S.Split(C);
    int length = S.Length;
    for (int i = length - 1; i >= 0; i--)
    {
    Console.Write(n[i]);
    if (i != 0)
    {
    Console.Write(" ");
    }
    }
    ```
8. C# 取两个数组的相同元素?
   * 摘要: 以往我们都是肯定绞尽脑汁，肯定什么循环，元素⼤⼩，什么因素都考虑进去。但是现在采⽤Linq可
   以很好的解决这个问题。找出两个或多个数组的相同项。代码如下
   ```C#
    usingSystem;
    usingSystem.Collections.Generic;
    usingSystem.Linq;
    usingSystem.Text;
    namespaceTest4_03
    {
    classProgram
    {
    staticvoidMain(string[] args)
    {
    string[] names = {"Adams","Arthur","Buchanan","Tsbuchis","ShCian","FuchsiaLinda","DecheChen","Lotheer","FindLanciCade",
    "SorchLand","JiangZheng","MisiiLoda","Gtod","Dfac","Lama","BakCades","Losangle","ZheWQ","GehengDahaLothi","ToryLandey",
    "DakaLothy","BthLanda","MenNorth","Fith","FoxMain","DontM","Saobba","Del","Sala","Ghero","BhthLaPhda"};
    IEnumerable<string> skip = names.Skip(10);
    IEnumerable<string> take = names.Take(11);
    //取出两个序列中交集部分，按理论应该输出JiangZheng
    IEnumerable<string> intersect = skip.Intersect(take);
    foreach (varsinintersect)
    {
    Console.WriteLine(s);
    }
    Console.ReadKey();
    }
    }
    }
   ```
9. 有1、2、3、4个数字，能组成多少个互不相同且⽆重复数字的三位数？都是多少？
    ```C#
    class Program
    {
    static void Main(string[] args)
    {
            //有1、2、3、4个数字，能组成多少个互不相同且⽆重复数字的三位数？都是多少？
            //分解题⽬
            //条件：四个数字1、2、3、4 ；三位数：百位、⼗位、个位
            //要求：互不相同；⽆重复数字：每个数字在三位中只出现⼀次
            //结果：多少个？ 都是多少？
    
            int count = 0; //统计个数
            for (int bw = 1; bw <= 4; bw++)
            {
                for (int sw = 1; sw <= 4; sw++)
                {
                    if (sw != bw) //很显然，只有百位和⼗位不同的情况下才能谈个位。
                    {
                        for (int gw = 1; gw <= 4; gw++)
                        {
                            21 if (gw != sw && gw != bw) //百位⽤过的，⼗位就不能⽤；百位和⼗位都⽤过的，个位就不能⽤
                            {
                                count++;
                                Console.WriteLine("{0}{1}{2}", bw, sw, gw);
                            }
                        }
                    }
                }
            }
            Console.WriteLine("⼀共有{0}个", count);
            Console.Read();
    
        }
    }
    ```
10. 产⽣⼀个int数组，⻓度为100，并向其中随机插⼊1-100，并且不能重复。
    ```C#
    int[] intArr = new int[100];
    ArrayList myList = new ArrayList();
    Random rnd = new Random();
    while (myList.Count < 100)
    {
    int num = rnd.Next(1, 101);
    if (!myList.Contains(num))
    myList.Add(num);
    }
    for (int i = 0; i < 100; i++)
    intArr[i] = (int)myList[i];
    ```
11. ⽤C#写⼀段选择排序算法，要求⽤⾃⼰的编程⻛格
    ```C#
    public void xuanZhe(int[] list)//选择排序
    {
    for (int i = 0; i < list.Length – 1; i++)
    {
    min = i;
    for (int j = i + 1; j < list.Length; j++)
    {
    if (list[j] < list[min])
    min = j;
    }
    int t = list[min];
    list[min] = list[i];
    list[i] = t;
    }
    }
    ```
12. 有⼀个10个数的数组，计算其中不重复数字的个数。{3,5,9,8,10,5,3},⽤HashSet。
    ```C#
    int[] values = { 3, 5, 9, 8, 10, 5, 3 };
    HashSet<int> set = new HashSet<int>();
    foreach (int i in values)
    {
    set.Add(i);
    }
    foreach (int i in set)
    {
    Console.WriteLine(i);
    }
    ```
13. Ａ、Ｂ、Ｃ、Ｄ、Ｅ五名学⽣有可能参加计算机竞赛，根据下列条件判断哪些⼈参加了竞
    赛：
    1. Ａ参加时，Ｂ也参加；
    2. Ｂ和Ｃ只有⼀个⼈参加；
    3. Ｃ和Ｄ或者都参加，或者都不参加；
    4. Ｄ和Ｅ中⾄少有⼀个⼈参加；
    5. 如果Ｅ参加，那么Ａ和Ｄ也都参加。
    ```C#
    static void Main(string[] args)
    {
    char[] name = { 'A', 'B', 'C', 'D', 'E' };
    int[] value = new int[5];
    for (value[0] = 0; value[0] < 2; value[0]++)
    for (value[1] = 0; value[1] < 2; value[1]++)
    for (value[2] = 0; value[2] < 2; value[2]++)
    for (value[3] = 0; value[3] < 2; value[3]++)
    for (value[4] = 0; value[4] < 2; value[4]++)
    {
    if ((value[1] >= value[0]) && (value[1] + value[2] == 1) && (value[2] == value[3]) && (value[3] + value[4] == 1) && (value[4] == 0 || value[4] == 1 && value[0] == 1 && value[3] == 1))
    {
    for (int i = 0; i < 5; i++)
    {
    if (value[i] == 1)
    {
    Console.WriteLine("{0}参加", name[i]);
    }
    else
    {
    Console.WriteLine("{0}不参加", name[i]);
    }
    }
    }
    }
    }
    ```
14. 程序设计: 猫⼤叫⼀声，所有的⽼⿏都开始逃跑，主⼈被惊醒。
    ```C#
    
    ```
15. ⼀列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少，⽤递归算
    法实现。
    ```C#
    public class MainClass
    {
    public static void Main()
    {
    Console.WriteLine(Foo(30));
    }
    public static int Foo(int i)
    {
    if (i <= 0)
    return 0;
    else if (i > 0 && i <= 2)
    return 1;
    else return Foo(i - 1) + Foo(i - 2);
    }
    }
    ```
## .NET/C#⾯试题汇总系列：数据库概念知识
1. 为什么要⼀定要设置主键?
    * 其实这个不是⼀定的，有些场景下，⼩系统或者没什么⽤的表，不设置主键也没关系，mysql最好是⽤⾃增
      主键，主要是以下两个原因：如果定义了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义
      主键，则innodb 会选择第⼀个不包含有NULL值的唯⼀索引作为主键索引、如果也没有这样的唯⼀索引，
      则innodb 会选择内置6字节⻓的ROWID作为隐含的聚集索引。所以，反正都要⽣成⼀个主键，那你还不如
      ⾃⼰指定⼀个主键，提⾼查询效率！
2. ⾃增主键⽤完了怎么办?
    * 在mysql中，Int整型的范围（-2147483648~2147483648），约20亿！因此不⽤考虑⾃增ID达到最⼤值
      这个问题。⽽且数据达到千万级的时候就应该考虑分库分表了
3. 为什么不直接存储图⽚、⾳频、视频等⼤容量内容?
    * 我们在实际应⽤中，都是⽂件形式存储的。mysql中，只存⽂件的存放路径。虽然mysql中blob类型可以⽤
      来存放⼤容量⽂件，但是，我们在⽣产中，基本不⽤！主要有如下⼏个原因：
      * Mysql内存临时表不⽀持TEXT、BLOB这样的⼤数据类型，如果查询中包含这样的数据，查询效率会⾮
      常慢。
      * 数据库特别⼤，内存占⽤⾼，维护也⽐较麻烦。
      * binlog太⼤，如果是主从同步的架构，会导致主从同步效率问题！因此，不推荐使⽤blob等类型！
4. 有⼏种不同的join?
   * Inner join, left join, right join, full join.
   * Inner join, 就是只要有⼀个列能够匹配， 就简单的返回两个table中所有的对应⾏。
   * Left join也就是left outer join。当有⼀个列能够匹配时就返回左边表中所有的⾏。
   * Right join也就是right outer join，当有列匹配时，返回右边表格中所有的⾏
   * Full join也就是full outer join, 当有匹配时， 会返回左边表格和右边表格任意情况下的⾏组合。
5. Sql和my sql的区别是什么?
   * Sql是结构化查询语⾔，my sql是⼀个关系型数据库.
6. Delete和truncate的区别是什么?
   * Delete是dml，truncate是ddl。
   * Delete是⽤来删除⼀⾏或者多⾏。Truncate是⽤来删除⼀个表中的所有⾏。
   * 我们可以⽤where跟delete结合使⽤。Truncate不可以。
7. Drop跟truncate的区别是什么?
   * truncate是删除表中所有的⾏，drop是删除整张表。这两个操作都不可以回撤。
8. 什么是关系？有⼏种关系?
   * 关系是指多表在数据库中的关联有4种关系:
     * 1对1，多对⼀，多对多，⼀对多.
9. 什么是主键？
   * 唯⼀标识⼀条记录，不能有重复的，不允许为空。
10. 什么是外键？
    * 表的外键是另⼀表的主键, 外键可以有重复的, 可以是空值。
11. 如何随机的从表中取⾏?
    * select * from tablename sample 10
12. Sql server的TCP/ip端⼝是什么?
    * 1433
13. 什么是SQL？
    * SQL（结构化查询语⾔）是⼀种设计⽤于检索和操作数据的数据库。它属于美国国家标准协会（ANSI）的
      ⼀种标准，可⽤于执⾏Select（选择）、Update（更新）、Delete（删除）和Insert（插⼊）等数据任
      务
14. SQL中的Constraints(约束)是什么?
    * 它可⽤于设置表中数据类型的限制。在创建或更新表语句时，可以使⽤约束。⼀些限制是：
    NOT NULL、PRIMARY KEY、FOREIGN KEY、UNIQUE、CHECK、DEFAULT
15. 什么是Index（索引）？
    * 索引⽤于加速查询的性能。它可以更快地从表中检索数据。可以在⼀组列上创建索引。
16. Clustered（群集）和Non-Clustered Index（⾮群集）索引之间有什么区别?
    * 聚集索引——有助于轻松检索数据，并且只有⼀个聚集索引与⼀个表⼀起分配。它会更改记录在数据库中
      的保存⽅式。
    * ⾮聚集索引——与聚集索引相⽐，⾮聚集索引很慢。并且在⾮集群索引的情况下，该表可以具有多个索
    引，为表创建⼀个对象，该表是搜索后指向表的⼀个点。
17. 什么是Aggregate Functions（聚合函数）？
    * 它是⼀个返回单个值的数学函数。SQL中的聚合函数是：
      * AVG（）——返回平均值
      * COUNT（）——返回⾏数
      * MAX（）——返回最⼤值
      * MIN（）——返回最⼩值
      * ROUND（）——基于⼗进制规范，此函数对数字字段进⾏舍⼊
      * SUM（）——返回总和
18. 主键是⽤⾃增还是UUID?
    * 最好是⽤⾃增主键，主要是以下两个原因：
       1. 如果表使⽤⾃增主键，那么每次插⼊新的记录，记录就会顺序添加到当前索引节点的后续位置，当⼀⻚写
       满，就会⾃动开辟⼀个新的⻚。
       2. 如果使⽤⾮⾃增主键（如uuid），由于每次插⼊主键的值近似于随机，因此每次新纪录都要被插到索引
       ⻚的随机某个位置，此时MySQL为了将新记录插到合适位置⽽移动数据，甚⾄⽬标⻚⾯可能已经被回写到
       磁盘上⽽从缓存中清掉，此时⼜要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分⻚操作造成
       索引碎⽚，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充⻚⾯。
    * 不过，也不是所有的场景下都得使⽤⾃增主键，可能场景下，主键必须⾃⼰⽣成，不在乎那些性能的开
       销。那也没有问题。
19. CHAR 和 VARCHAR 的区别？
    * char和varchar类型声明⻓度表示⽤户想保存的最⼤字符数，其中char(M)定义的列的⻓度为固定的，M的
      取值可以0-255之间，当保存char值时，在它们的右边填充空格以达到指定的⻓度。
    * 当检索到char值时，尾部的空格被删除掉。在存储或检索过程中不进⾏⼤⼩写转换。char存储定⻓数据很
      ⽅便，char字段上的索引效率很⾼。
    * varchar(M)定义的列的⻓度是可变⻓度字符串，在MySQL5.0以上的版本中，varchar的数据类型⻓度⽀持
      到了65535，因为起始位和结束位占去了3个字节，所以其整体最⼤⻓度为65532字节（varchar的最⼤有
      效⻓度由最⼤⾏⼤⼩和使⽤的字符集确定）。
    * 同样在char和varchar尾部加空格，检索时char类型后的被删掉，⽽varchar类型的保存。
20. 主键为什么不推荐有业务含义?
    * 最好是主键是⽆意义的⾃增ID，然后另外创建⼀个业务主键ID， 因为任何有业务含义的列都有改变的可能
    性,主键⼀旦带上了业务含义，那么主键就有可能发⽣变更。主键⼀旦发⽣变更，该数据在磁盘上的存储位
    置就会发⽣变更，有可能会引发⻚分裂，产⽣空间碎⽚。
    * 还有就是，带有业务含义的主键，不⼀定是顺序⾃增的。那么就会导致数据的插⼊顺序，并不能保证后⾯
    插⼊数据的主键⼀定⽐前⾯的数据⼤。如果出现了，后⾯插⼊数据的主键⽐前⾯的⼩，就有可能引发⻚分
    裂，产⽣空间碎⽚。
21. 货币字段⽤什么类型?
    * 货币字段⼀般都⽤ Decimal类型， float和double是以⼆进制存储的，数据⼤的时候，可能存在误差 。
22. 索引应该建在那些列上？
    * 在经常需要搜索的列上，可以加快搜索的速度；
    * 在作为主键的列上，强制该列的唯⼀性和组织表中数据的排列结构；
    * 在经常⽤在连接的列上，这些列主要是⼀些外键，可以加快连接的速度；
    * 在经常需要根据范围进⾏搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
    * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利⽤索引的排序，加快排序查询时
    间；
    * 在经常使⽤在WHERE⼦句中的列上⾯创建索引，加快条件的判断速度。
23. 什么是存储过程？有哪些优缺点？
    * 存储过程就像我们编程语⾔中的函数⼀样，封装了我们的代码(PLSQL、T-SQL)
    * 存储过程的优点
      * 能够将代码封装起来
      * 保存在数据库之中
      * 让编程语⾔进⾏调⽤
      * 存储过程是⼀个预编译的代码块，执⾏效率⽐较⾼
      * ⼀个存储过程替代⼤量T_SQL语句 ，可以降低⽹络通信量，提⾼通信速率
    * 存储过程的缺点：
      * 每个数据库的存储过程语法⼏乎都不⼀样，⼗分难以维护（不通⽤）
      * 业务逻辑放在数据库上，难以迭代
24. 字段为什么要定义为NOT NULL？
    * ⼀般情况，都会设置⼀个默认值，不会出现字段⾥⾯有null，⼜有空的情况。主要有以下⼏个原因：
      * 索引性能不好，Mysql难以优化引⽤可空列查询，它会使索引、索引统计和值更加复杂。
      * 可空列需要更多的存储空间，还需要mysql内部进⾏特殊处理。
      * 可空列被索引后，每条记录都需要⼀个额外的字节，还能导 致MYisam 中固定⼤⼩的索引变成可变⼤⼩的索引。
      * 如果某列存在null的情况，可能导致count() 等函数执⾏不对的情况。看⼀下2个图就明⽩了：
        * sql 语句写着也麻烦，既要判断是否为空，⼜要判断是否为null等。
25. 索引的分类有哪些?
    * 唯⼀索引：唯⼀索引不允许两⾏具有相同的索引值
    * 主键索引：为表定义⼀个主键将⾃动创建主键索引，主键索引是唯⼀索引的特殊类型。主键索引要求主键
      中的每个值是唯⼀的，并且不能为空
    * 聚集索引(Clustered)：表中各⾏的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有⼀个
    * ⾮聚集索引(Non-clustered)：⾮聚集索引指定表的逻辑顺序。数据存储在⼀个位置，索引存储在另⼀个位
      置，索引中包含指向数据存储位置的指针。可以有多个，⼩于249个
26. 时间字段⽤什么类型?
    * 这个看具体情况和实际场景，timestamp ，datatime ，bigint 都⾏！把理由讲清楚就⾏！
    * timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19
      11:14:07。2038年以后的时间，是⽆法⽤timestamp类型存储的。
    * 但是它有⼀个优势，timestamp类型是带有时区信息的。⼀旦你系统中的时区发⽣改变，例如你修改了时
      区，该字段的值会⾃动变更。这个特性⽤来做⼀些国际化⼤项⽬，跨时区的应⽤时，特别注意！
    * datetime，占⽤8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显
      然，存储时间范围更⼤。但是它坑的地⽅在于，它存储的是时间绝对值，不带有时区信息。如果你改变数
      据库的时区，该项的值不会⾃⼰发⽣变更！
    * bigint，也是8个字节，⾃⼰维护⼀个时间戳，查询效率⾼，不过数据写⼊，显示都需要做转换。
27. 什么是最左前缀原则？
    * 最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续⼀列或⼏列，则此列就可以被⽤
      到。如下:
    > select * from user where name=xx and city=xx ; ／／可以命中索引
    > select * from user where name=xx ; // 可以命中索引
    > select * from user where city=xx ; // ⽆法命中索引
    * 这⾥需要注意的是，查询的时候如果两个条件都⽤上了，但是顺序不同，如 city= xx and name ＝xx，那
      么现在的查询引擎会⾃动优化为匹配联合索引的顺序，这样是能够命中索引的。
    * 由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前
      ⾯。ORDER BY⼦句也遵循此规则。
28. 什么是事务？
    * 事务简单来说：⼀个Session中所进⾏所有的操作，要么同时成功，要么同时失败
      ACID — 数据库事务正确执⾏的四个基本要素包含：
      * 原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
      * ⼀个⽀持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction
      processing）当中⽆法保证数据的正确性，交易过程极可能达不到交易。
      * 举个例⼦:A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来⼀样【A账户的钱没变，
      B账户的钱也没变】
29. mysql有关权限的表都有哪⼏个?
    * MySQL服务器通过权限表来控制⽤户对数据库的访问，权限表存放在mysql数据库⾥，由
    mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下⾯分别
    介绍⼀下这些表的结构和内容：
      * user权限表：记录允许连接到服务器的⽤户帐号信息，⾥⾯的权限是全局级的。
      * db权限表：记录各个帐号在各个数据库上的操作权限。
      * table_priv权限表：记录数据表级的操作权限。
      * columns_priv权限表：记录数据列级的操作权限。
      * host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和
      REVOKE语句的影响。
30. 什么情况下应不建或少建索引?
    * 表记录太少
    * 经常插⼊、删除、修改的表
    * 数据重复且分布平均的表字段，假如⼀个表有10万⾏记录，有⼀个字段A只有T和F两种值，且每个值的分
      布概率⼤约为50%，那么对这种表A字段建索引⼀般不会提⾼数据库的查询速度。
    * 经常和主字段⼀块查询但主字段索引值⽐较多的表字段
31. 数据表损坏的修复⽅式有哪些？
    * 使⽤ myisamchk 来修复，具体步骤：
      1. 修复前将mysql服务停⽌。
      2. 打开命令⾏⽅式，然后进⼊到mysql的/bin⽬录。
      3. 执⾏myisamchk –recover 数据库所在路径/*.MYI
        * 使⽤repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE
        TABLE table_name 优化表 REPAIR TABLE ⽤于修复被破坏的表。
        * OPTIMIZE TABLE ⽤于回收闲置的数据库空间，当表上的数据⾏被删除时，所占据的磁盘空间并没有⽴即
        被回收，使⽤了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据⾏进⾏重排（注意：是
        磁盘上，⽽⾮数据库）
32. MySQL数据库cpu飙升到100%的话他怎么处理？
    * 列出所有进程 show processlist 观察所有进程 多秒没有状态变化的(⼲掉)
    * 查看慢查询，找出执⾏时间⻓的sql；
    * explain分析sql是否⾛索引，sql优化；
    * 检查其他⼦系统是否正常，是否缓存失效引起，需要查看buffer命中率；
33. 维护数据库的完整性和⼀致性，你喜欢⽤触发器还是⾃写业务逻辑？为什么？
    * 尽可能使⽤约束，如check,主键，外键，⾮空字段等来约束，这样做效率最⾼，也最⽅便。其次是使⽤触
      发器，这种⽅法可以保证，⽆论什么业务系统访问数据库都可以保证数据的完整新和⼀致性。
      最后考虑的是⾃写业务逻辑，但这样做麻烦，编程复杂，效率低下。
34. 游标是什么？
    * 是对查询出来的结果集作为⼀个单元来有效的处理。游标可以定在该单元中的特定⾏，从结果集的当前⾏
      检索⼀⾏或多⾏。可以对结果集当前⾏做修改。⼀般不使⽤游标，但是需要逐条处理数据的时候，游标显
      得⼗分重要。
35. 数据库NULL是什么意思?
    * NULL(空)这个值是数据库世界⾥⼀个⾮常难缠的东⻄。
    * NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。假设您的SQL Server数据库⾥有ANSI_NULLS，当然在默认情况下会有，对NULL这个值的任何⽐较都会⽣产⼀个NULL值。您不能把任何
    值与⼀个 UNKNOWN值进⾏⽐较，并在逻辑上希望获得⼀个答案。您必须使⽤IS NULL操作符。
36. 关系型数据库和⾮关系型数据库区别？
    * 关系型数据库的优点：
      1. 容易理解：⼆维表结构是⾮常贴近逻辑世界⼀个概念，关系模型相对⽹状、层次等其他模型来说更容易
      理解；
      2. 使⽤⽅便：通⽤的SQL语⾔使得操作关系型数据库⾮常⽅便；
      3. 易于维护：丰富的完整性(实体完整性、参照完整性和⽤户定义的完整性)⼤⼤减低了数据冗余和数据不
      ⼀致的概率；
      4. ⽀持SQL，可⽤于复杂的查询。
      5. ⽀持事务
    * 关系型数据库的缺点：
      1. 为了维护⼀致性所付出的巨⼤代价就是其读写性能⽐较差；
      2. 固定的表结构；
      3. 不⽀持⾼并发读写需求；
      4. 不⽀持海量数据的⾼效率读写
    * ⾮关系型数据库优点：
      1. ⽆需经过sql层的解析，读写性能很⾼
      2. 基于键值对，数据没有耦合性，容易扩展
      3. 存储数据的格式：nosql的存储格式是key,value形式
    * ⾮关系型数据库缺点：
      * 不提供sql
37. 查询语句的执⾏先后顺序？
    * 查询中⽤到的关键词主要包含六个，并且他们的顺序依次为 select--from--where--group by--
      having--order by
    * 其中select和from是必须的，其他关键词是可选的，这六个关键词的执⾏顺序 与sql语句的书写顺序并不
      是⼀样的，⽽是按照下⾯的顺序来执⾏:
        * from:需要从哪个数据表检索数据
        * where:过滤表中数据的条件
        * group by:如何将上⾯过滤出的数据分组
        * having:对上⾯已经分组的数据进⾏过滤的条件
        * select:查看结果集中的哪个列，或列的计算结果
        * order by :按照什么样的顺序来查看返回的数据
38. 什么情况下会造成死锁？
    * 所谓死锁: 是指两个或两个以上的进程在执⾏过程中。因争夺资源⽽造成的⼀种互相等待的现象,若⽆外⼒
      作⽤,它们都将⽆法推进下去。此时称系统处于死锁状态或系统产⽣了死锁,这些永远在互相等竺的进程称为
      死锁进程。表级锁不会产⽣死锁.所以解决死锁主要还是针对于最常⽤的InnoDB。
    * 死锁的关键在于：两个(或以上)的Session加锁的顺序不⼀致。
    * 那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。
39. 死锁如何解决?
    * 查出的线程杀死 kill
    > SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
    * 设置锁的超时时间
      * Innodb ⾏锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）
      * ⽣产环境不推荐使⽤过⼤的 innodb_lock_wait_timeout参数值
      * 该参数⽀持在会话级别修改，⽅便应⽤在会话级别单独设置某些特殊操作的⾏锁等待超时时间，如下：
      > set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb ⾏锁等待超时时
      间，单位秒。
40. 触发器的作⽤？
    触发器是⼀中特殊的存储过程，主要是通过事件来触发⽽被执⾏的。它可以强化约束，来维护数据的完整
    性和⼀致性，可以跟踪数据库内的操作从⽽不允许未经许可的更新和变化。可以联级运算。如，某表上的
    触发器上包含对另⼀个表的数据操作，⽽该操作⼜会导致该表触发器被触发。
41. 在数据库中查询语句速度很慢，如何优化？
    1. 建索引 ,
    2. 减少表之间的关联 
    3. 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该⾛索引,把数据 量⼤的表排在前⾯ 
    4. 简化查询字段，没⽤的字段不要，已经对返回结果的控制，尽量返回少量数据
    5. 尽量⽤PreparedStatement来查询，不要⽤Statement
42. 什么是PL/SQL?
    * PL/SQL是⼀种程序语⾔，叫做过程化SQL语⾔（Procedural Language/SQL）。PL/SQL是Oracle数据
      库对SQL语句的扩展。在普通SQL语句的使⽤上增加了编程语⾔的特点，所以PL/SQL把数据操作和查询
      语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。PL/SQL
      只有 Oracle 数据库有。 MySQL ⽬前不⽀持 PL/SQL 的。
43. 使⽤SQL命令将教师表teacher中⼯资salary字段的值增加500，应该使⽤的命令?
    * Update teacher set salary=salary+500
44. mdf、.ldf、.tif 、.ndf哪个不是sql 数据库⽂件的后缀？
    .tif
45. SQL语⾔中，条件“年龄BETWEEN 40 AND 50”表示年龄在40⾄50之间更准确的描述是?
    包括40岁和50.
46. drop、delete与truncate分别在什么场景之下使⽤？
    * SQL中的drop、delete、truncate都表示删除，但是三者有⼀些差别
      * delete和truncate只删除表的数据不删除表的结构
      * 速度,⼀般来说: drop> truncate >delete
      * delete语句是dml,这个操作会放到rollback segement中,事务提交之后才⽣效;
      * 如果有相应的trigger,执⾏的时候将被触发. truncate,drop是ddl, 操作⽴即⽣效,原数据不放到rollback
      segment中,不能回滚. 操作不触发trigger.
      * 不再需要⼀张表的时候，⽤drop
      * 想删除部分数据⾏时候，⽤delete，并且带上where⼦句
      * 保留表⽽删除所有数据的时候⽤truncate
47. MyISAM索引与InnoDB索引的区别？
    * InnoDB索引是聚簇索引，MyISAM索引是⾮聚簇索引。
    * InnoDB的主键索引的叶⼦节点存储着⾏数据，因此主键索引⾮常⾼效。
    * MyISAM索引的叶⼦节点存储的是⾏数据地址，需要再寻址⼀次才能得到数据。
    * InnoDB⾮主键索引的叶⼦节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会⾮常⾼效
48. 有哪⼏种类型的SQL命令？
    * SQL命令分为以下类型：
      * DDL（数据定义语⾔） - ⽤于定义数据库的结构。
      * DCL（数据控制语⾔） - ⽤于为⽤户提供权限。
      * DML（数据操作语⾔） - ⽤于管理数据。
      * DQL（数据查询语⾔） - 所有命令都在SQL中，⽤于检索DQL中的数据。
      * TCL（事务控制语⾔） - ⽤于管理DML所做的更改。
## .NET/C#⾯试题汇总系列：数据库SQL查询（附建表语句）
