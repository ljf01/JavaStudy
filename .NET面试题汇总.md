## .NET面试题汇总系列(一)：基础语法
1. 字符串中string str=null和string str=""和string str=string.Empty的区别  
string.Empty相当于“”,Empty是一个静态只读的字段。 string str="" ,初始化对象，并分配一个空字符串的内存空间 string str=null,初始化对象，不会分配内存空间

2. byte b = 'a'; byte c = 1; byte d = 'ab'; byte e = '啊'; byte g = 256; 这些变量有些错误是错再哪里?  
本题考查的是数据类型能承载数据的大小。
1byte =8bit，1个汉字=2个byte，1个英文=1个byte=8bit
所以bc是对的，deg是错的。'a'是char类型，a错误
java byte取值范围是-128~127, 而C#里一个byte是0~255
3. string和StringBuilder的区别,两者性能的比较  
都是引用类型，分配在堆上
StringBuilder默认容量是16，可以允许扩充它所封装的字符串中字符的数量.每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。
对于简单的字符串连接操作，在性能上stringbuilder不一定总是优于strin因为stringbulider对象的创建也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder的使用。从最后分析可以看出如果是相对较少的字符串拼接根本看不出太大差别。
Stringbulider的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分配操作，是不妥的实现方法。 参考链接：https://www.cnblogs.com/haofuqi/p/4826262.html
4. 什么是扩展方法？  
一句话解释，扩展方法使你能够向现有类型“添加”方法，无需修改类型
条件：按扩展方法必须满足的条件，1.必须要静态类中的静态方法2.第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法
建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现
使用：不能通过类名调用，直接使用类型来调用
5. byte a =255;a+=5;a的值是多少？
byte的取值范围是-2的8次方至2的8次方-1，-256至258，a+=1时，a的值时0，a+=5时，a的值是0，所以a+=5时，值是4

6. 什么是装箱和拆箱？
装箱就是隐式地将一个值类型转换成引用类型，如：
int i=0;
Syste.Object obj=i;
拆箱就是将引用类型转换成值类型，如：
int i=0;
System.Object obj=i;
int j=(int)obj;（将obj拆箱）
7. 值类型和引用类型的区别
值类型变量是直接包含值。将一个值类型变量赋给另一个值类型变量，是复制包含的值，默认值是0。
引用类型变量的赋值只复制对对象的引用，而不复制对象本身，默认值是null
值类型有整形、浮点型、bool、枚举。
引用类型有class、delegate、Object、string
值类型存储在栈中，引用类型存储在堆中
8. new关键字的作用
运算符：创建对象实例
修饰符：在派生类定义一个重名的方法，隐藏掉基类方法
约束：泛型约束定义，约束可使用的泛型类型,如：
public class ItemFactory<T> where T : IComparable, new()
   {
   }
9. int?和int有什么区别
int？为可空类型，默认值可以是null
int默认值是0
int?是通过int装箱为引用类型实现
10. C#中的委托是什么？
一句话解释就是：将方法当作参数传入另一个方法的参数。 .net中有很多常见的委托如：Func 、Action 作用：提高方法的扩展性

11. 用最有效的方法算出2乘以8等于几？
位运算是最快，使用的是位运算 逻辑左位移<<。 方法是2<<3相当于0000 0000 0000 0010 （2的16位int二进制）左移三位就是 0000 0000 0001 0000（16的二进制）

12. const和readonly有什么区别？
都可以标识一个常量。主要有以下区别：

1. 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在静态构造方法（必须是静态构造方法，普通构造方法不行）里赋值。
2. 修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段
3. const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。
4. const默认是静态的；而readonly如果设置成静态需要显示声明
5. 修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。
13. 现有一个整数number，请写一个方法判断这个整数是否是2的N次方  
    4（100）、5（101）、8（1000）、16（10000）  
取模运算： 用number%2==0可以判断，但是这个有点低级  
位运算：（使用位运算逻辑并，两个位上的都为1才是1，其余都是0，判断是否等于0）  
4&3相当于100&011 ，结果是000等于0，所以4是2的n次方  
5&4相当于101&100，结果是100不等于0，所以5不是2的n次方  
如果要问如果是2的N次方，这个N是多少？这该怎么算？  
```C#
private static byte get(int n)
    {
        byte number = 1;
        while (n/2!=1)
        {
            n = n / 2;
            number += 1;
        }
        return number;
    }
```
14. CTS、CLS、CLR分别作何解释
CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。

CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。
CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。
CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。
15. 在.net中，配件的意思是？
程序集。（中间语言，源数据，资源，装配清单）

16. 分析下面代码，a、b的值是多少？
string strTmp = "a1某某某";
int a = System.Text.Encoding.Default.GetBytes(strTmp).Length;
int b = strTmp.Length;
分析：一个字母、数字占一个byte，一个中文占占两个byte，所以a=8,b=5

17. Strings = new String(“xyz”);创建了几个String Object?
两个对象，一个是“xyz”,一个是指向“xyz”的引用对象s。

18. 静态成员和非静态成员的区别
1.静态成员用statis修饰符声明，在类被实例化时创建，通过类进行访问
2.不带statis的变量时非静态变量，在对象被实例化时创建，通过对象进行访问，
3.静态方法里不能使用非静态成员，非静态方法可以使用静态成员
4.静态成员属于类，而不属于对象
19. c#可否对内存直接操作
C#在unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针，C#NET默认不运行带指针的，需要设置下，选择项目右键->属性->选择生成->“允许不安全代码”打勾->保存

20. short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
s1+1不能显式转换成short类型，可以修改为s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1正确

21. 什么是强类型，什么是弱类型？哪种更好些？为什么?
强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如javascript,vb,php等

22. using关键字的作用
1. 引用命名空间，也可using 别名
2. 释放资源，实现了IDisposiable的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源。
23. ref和out有什么区别
1. 都是按引用类型进行传递
2. 属性不是变量不能作为out、ref参数传递
3. ref参数必须初始化。out不需要初始化
4. 作用，当方法有多个返回值时，out非常有用
24. a.Equals(b)和a==b一样吗？
不一样，a==b仅仅表示a和b值相等，a.Equals(b)表示a与b一致

25. 下面这段代码求值
```C#
class Class1
    {
        internal static int count = 0;
        static Class1()
        {
            count++;
        }
        public Class1()
        {
            count++;
        }
    }
    Class1 o1 = new Class1();
    Class1 o2 = new Class1();
  o1.count的值是多少？

答案：3，静态 构造方法计算一次，两个实例化对象计算两次。
```

26. 关于构造函数说法正确的是哪个？
    1. 构造函数可以声明返回类型。  

    2.  构造函数不可以用private修饰  

    3.  构造函数必须与类名相同  
 
    4.  构造函数不能带参数  

    答案：3,构造函数必须与类名相同，可以传递多个传递，作用就是便于初始化对象成员，不能有任何返回类型  

27. Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?
Math.Round(11.5)=12  
Math.Round(-11.5)=-12  
28. &和&&的区别
* 相同点
  * &和&&都可作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，其结果才为true，否则，只要有一方为false，则结果为false。（ps：当要用到逻辑与的时候&是毫无意义，&本身就不是干这个的）

* 不同点
* if(loginUser!=null&&string.IsnullOrEmpty(loginUser.UserName))
  &&具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，对于上面的表达式，当loginUser为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。（ps：所以说当要用到逻辑与的时候&是毫无意义的）

* & 是用作位运算的。

* 总结
  * &是位运算，返回结果是int类型 &&是逻辑运算，返回结果是bool类型

29. i++和++i有什么区别？
    1. i++是先赋值，然后再自增；++i是先自增，后赋值。
    2. i=0，i++=0，++i=1； Console.WriteLine(++i==i++); 结果位true
30. as和is的区别    
    as在转换的同时判断兼容性，如果无法进行转换，返回位null（没有产生新的对象），as转换是否成功判断的依据是是否位null is只是做类型兼容性判断，并不执行真正的类型转换，返回true或false，对象为null也会返回false。
as比is效率更高，as只需要做一次类型兼容检查

## .NET面试题汇总系列(二)：面向对象
1. 什么是构造函数？
* 概念：构造函数的方法名与类型相同、没有返回类型

* 作用：完成对类的对象初始化

  * 创建一个类的新对象时，系统会自动调用该构造函数初始化新对象， 如果没有写定义，那么系统会自动提供一个不带任何参数的public 构造函数

2. class和struct的区别?
* 相同点 都可以实现接口

* 不同点

  1. class是引用类型，struct是值类型
  2. class允许继承、被继承，struct不允许，只能继承接口
  3. class可以初始化变量，struct不可以
  4. class可以有无参的构造函数，struct不可以，必须是有参的构造函数，而且在有参的构造函数必须初始化所有成员
* 使用场景

  1. Class比较适合大的和复杂的数据，表现抽象和多级别的对象层次时。
  2. Struct适用于作为经常使用的一些数据组合成的新类型，表示诸如点、矩形等主要用来存储数据的轻量级对象时，偏简单值。
  3. Struct有性能优势，Class有面向对象的扩展优势。
3. 简述一下面向对象的三大特性？
* 封装、继承、多态。
* 封装：是通过把对象的属性的实现细节隐藏起来，仅对外提供公共的访问方法。
* 继承：是通过子类继承基类、继承抽象类、继承接口实现的。
* 多态：是通过重写基类的override 方法、重写虚方法实现的。 好处是：方便维护、易扩展。 缺点是：比面向过程性能低。
4. 构造函数是否能被重写？
构造器Constructor不能被继承，因此不能重写，但可以被重载

5. 抽象类和接口有什么区别？
* 相同点：都不能直接实例化 
* 不同点：
  1. 抽象类用abstract修饰、接口用interface修饰
  2. 抽象类中的方法可以实现，也可以不实现，有抽象方法的类一定要用abstract修饰，接口中的方法不允许实现
  3. 抽象类只能单继承，接口支持多实现
  4. 抽象类有构造方法，接口不能有构造方法
  5. 接口只负责功能的定义，通过接口来规范类的，（有哪些功能），而抽象类即负责功能的定义有可以实现功能（实现了哪些功能）
  6. 类的执行顺序？
     * 执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法

7. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？
   * 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实现类，但前提是实现类必须有明确的构造函数。

8. 继承最大的好处？
   * 对父类成员进行重用，增加代码的可读性、灵活性。

9. 请说说引用和对象?
   * 对象和引用时分不开的，对象生成一个地址，放在堆里面，引用则指向这个地址，放在栈里面

10. 什么是匿名类，有什么好处？
    * 不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。

11. 重写和重载的区别?
* 重写方法：关键字用override修饰，派生类重写基类的方法，方法命名、返回类型，参数必须相同
* 重载方法：方法名必须相同，参数列表必须不相同，返回类型可以不相同。
* 作用：重写主要是实现面向对象的多态性、重载主要是实现实例化不同的对象
12. C#中有没有静态构造函数，如果有是做什么用的？
* 特点：静态构造函数既没有访问修饰符，也没有参数。在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数来初始化类。无法直接调用静态构造函数。在程序中，用户无法控制何时执行静态构造函数。 
* 用途：当类使用日志文件时，将使用这种构造函数向日志文件中写入项。

13. 怎样理解静态变量？静态成员和非静态成员的区别？
* 静态变量属于类，而不属于对象；并对所有对象所享；静态成员在加类的时候就被加载。

14. 属性能在接口中声明吗？
* 可以，不能有访问修饰符，不能初始化赋值。

15. 在项目中为什么使用接口？接口的好处是什么？什么是面向接口开发？
    * 接口是一种约束，描述类的公共方法/公共属性，不能有任何的实现
    * 好处是：结构清晰，类之间通信简单易懂，扩展性好，提高复用性。
    * 面向interface编程，原意是指面向抽象协议编程，实现者在实现时要严格按协议来办。
16. 什么时候用重载？什么时候用重写？
* 当一个类需要用不同的实现来做同一件事情，此时应该用重写，而重载是用不同的输入做同一件事情

17. 静态方法可以访问非静态变量吗？如果不可以为什么？
* 静态方法和非静态变量不是同一生命周期，静态方法属于类，非静态变量属于具体的对象，静态方法和具体的对象没有任何关联

18. 在.Net中所有可序列化的类都被标记为_?
* [serializable]

19. C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
* 一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质

20. 当使用new B()创建B的实例时，产生什么输出？
```C#
   using System;
    class A
    {
          public A()
          {
                PrintFields();
          }
          public virtual void PrintFields(){}
      }
      class B:A
      {
           int x=1;
           int y;
           public B()
           {
               y=-1;
           }
           public override void PrintFields()
           {
               Console.WriteLine("x={0},y={1}",x,y);
           }
     }
答：X=1,Y=0;
```

21. 能用foreach遍历访问的对象需要实现 ____接口或声明____方法的类型
* 答：IEnumerable 、 GetEnumerator。

## .NET/C#⾯试题汇总系列：集合、异常、泛型、LINQ、委托、EF！
1. IList 接⼝与List的区别是什么?
* IList 泛型接⼝是 Icollection 接⼝的⼦代，并且是所有⾮泛型列表的基接⼝。 
* Ilist 实现有三种类别：只读、固定⼤⼩、可变⼤⼩。 ⽆法修改只读 Ilist。 固定⼤⼩的 Ilist 不允许添加或移除元素，但允许修改现
  有元素。 可变⼤⼩的 Ilist 允许添加、移除和修改元素。
* IList 是个接⼝,定义了⼀些操作⽅法这些⽅法要你⾃⼰去实现，当你只想使⽤接⼝的⽅法时,这种⽅式⽐较
  好.他不获取实现这个接⼝的类的其他⽅法和字段，有效的节省空间．
* List 是个类型已经实现了IList 定义的那些⽅法。
2. 泛型的主要约束和次要约束是什么？-
*  当⼀个泛型参数没有任何约束时，它可以进⾏的操作和运算是⾮常有限的，因为不能对实参进⾏任何类型上的保证，
   这时候就需要⽤到泛型约束。泛型的约束分为：主要约束和次要约束，它们都使实参必须满⾜⼀定的规范，
   C#编译器在编译的过程中可以根据约束来检查所有泛型类型的实参并确保其满⾜约束条件。
* 主要约束
   * ⼀个泛型参数⾄多拥有⼀个主要约束，主要约束可以是⼀个引⽤类型、class或者struct。如果指定⼀个引⽤类型（class），
     那么实参必须是该类型或者该类型的派⽣类型。相反，struct则规定了实参必须是⼀个值类型。下⾯的代码展示了泛型参数主要约束：
```C#
 public class ClassT1<T> where T : Exception
 {
    private T myException;
    public ClassT1(T t)
    {
        myException = t;
    }
    public override string ToString()
    {
        // 主要约束保证了myException拥有source成员
        return myException.Source;
    }
}
public class ClassT2<T> where T : class
{
    private T myT;
    public void Clear()
    {
        // T是引⽤类型，可以置null
        myT = null;
    }
}
public class ClassT3<T> where T : struct
{
    private T myT;
    public override string ToString()
    {
        // T是值类型，不会发⽣NullReferenceException异常
        return myT.ToString();
    }
}
```
* 次要约束
  * 次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型，可以有0到⽆限的次要约束，次要约束规定了实参必须实现所有的次要约束中规定的接⼝。
    次要约束与主要约束的语法基本⼀致，区别仅在于提供的不是⼀个引⽤类型⽽是⼀个或多个接⼝。例如我们为上⾯代码中的ClassT3增加⼀个次要约束：
```C#
public class ClassT3<T> where T : struct, IComparable
{
    ......
}
```
3. 如何把⼀个array复制到arrayist⾥?
```C#
foreach( object arr in array)
{
    arrayist.Add(arr);
}
```
4. List, Set, Map是否继承⾃Collection接⼝?
List，Set是，Map不是
5. Set⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?
* Set⾥的元素是不能重复的，那么⽤iterator()⽅法来区分重复与否。
* equals()是判读两个Set是否相等。equals()和==⽅法决定引⽤值是否指向同⼀对像，equals()在类中被覆盖，
  为的是当两个分离的对象的内容和类型相配的话，返回真值。
6. 有50万个int类型的数字，现在需要判断⼀下⾥⾯是否存在重复的数字，请你简要说⼀下思路。
* 使⽤C#的List集合⾃带的去重⽅法，例如 Distinct()，GroupBy()等。
* 利⽤ Dictionary 的Key值唯⼀的特性，HashSet 元素值唯⼀的特性 进⾏判断。
7. 数组有没有length()这个⽅法? String有没有length()这个⽅法 ？
* 数组没有length()这个⽅法，有length的属性。String有有length()这个⽅法。
8. ⼀个整数List中取出最⼤数（找最⼤值）。不能⽤Max⽅法。
```C#
private static int GetMax(List<int> list)
{
    int max = list[0];
    for (int i = 0; i < list.Count; i++)
    {
        if (list[i]>max)
        {
            max = list[i];
        }   
    }
    return max;
}
```
9. C#异常类有哪些信息？
* C#中，所有异常都继承⾃System.Exception类，Exception类定义了C#异常应该具有的信息和⽅法。值得注意的属性有：
```C#
public virtual string Message { get; }// 错误的信息，⽂字描述
public virtual string StackTrace { get; }// 发⽣异常的调⽤堆栈信息
public System.Reflection.MethodBase TargetSite { get; }//引发这个错误的⽅法
public Exception InnerException { get; }// ⼦异常
```
10. 如何创建⼀个⾃定义异常？
* 根据类继承原则和异常处理原则，我们可以使⽤以下⽅式来⾃定义⼀个类：
```C#
public class CustomException:Exception{}
```
11. 利⽤IEnumerable实现斐波那契数列⽣成?
```C#
IEnumerable<int> GenerateFibonacci(int n)
{
    if (n >= 1) yield return 1;

    int a = 1, b = 0;
    for (int i = 2; i <= n; ++i)
    {
        int t = b;
        b = a;
        a += t;
        yield return a;
    }
 }
 ```
12. 请利⽤ foreach 和 ref 为⼀个数组中的每个元素加 1
* 注意 foreach 不能⽤ var ，也不能直接⽤ int ，需要 ref int ，注意 arr 要转换为 Span 。
```C#
int[] arr = { 1, 2, 3, 4, 5};
Console.WriteLine(string.Join(",", arr)); // 1,2,3,4,5
foreach (ref int v in arr.AsSpan())
{
    v++;
}
Console.WriteLine(string.Join(",", arr)); // 2,3,4,5,6
```
13. 如何针对不同的异常进⾏捕捉？
```C#
public class Program
{
    public static void Main(string[] args)
    {
        Program p = new Program();
        p.RiskWork();

        Console.ReadKey();
    }

    public void RiskWork()
    {
        try
        {
            // ⼀些可能会出现异常的代码
        }
        catch (NullReferenceException ex)
        {
            HandleExpectedException(ex);
        }
        catch (ArgumentException ex)
        {
            HandleExpectedException(ex);
        }
        catch (FileNotFoundException ex)
        {
            HandlerError(ex);
        }
        catch (Exception ex)
        {
            HandleCrash(ex);
        }
    }
    //这⾥处理预计可能会发⽣的，不属于错误范畴的异常
    private void HandleExpectedException(Exception ex)
    {
        // 这⾥可以借助log4net写⼊⽇志
        Console.WriteLine(ex.Message);
    }

    // 这⾥处理在系统出错时可能会发⽣的，⽐较严重的异常
    private void HandlerError(Exception ex)
    {
        // 这⾥可以借助log4net写⼊⽇志
        Console.WriteLine(ex.Message);
        // 严重的异常需要抛到上层处理
        throw ex;
    }

    // 这⾥处理可能会导致系统崩溃时的异常
    private void HandleCrash(Exception ex)
    {
        // 这⾥可以借助log4net写⼊⽇志
        Console.WriteLine(ex.Message);
        // 关闭当前程序
        System.Threading.Thread.CurrentThread.Abort();
    }
}

```
14. 如何避免类型转换时的异常？
* 其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类引⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。
* 当⼀个不正确的类型转换发⽣时，会产⽣InvalidCastException异常，有时我们会⽤try-catch块做⼀些尝试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源的机制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较⾼，并且在尝试性类型转换时，这些信息都没有意义。在.NET中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。
1. is 只负责检查类型的兼容性，并返回结果：true 和 false。→ 进⾏类型判断;
```C#
public static void Main(string[] args)
{
    object o = new object();
    // 执⾏类型兼容性检查
    if(o is ISample)
    {
    // 执⾏类型转换
    ISample sample = (ISample)o;
    sample.SampleShow();
    }
    Console.ReadKey();
 }
```
2. as 不仅负责检查兼容性还会进⾏类型转换，并返回结果，如果不兼容则返回 null 。→ ⽤于类型转型
1 public static void Main(string[] args)
2 {
3 object o = new object();
4 // 执⾏类型兼容性检查
5 ISample sample = o as ISample;
6 if(sample != null)
7 {
8 sample.SampleShow();
9 }
10 Console.ReadKey();
11 }