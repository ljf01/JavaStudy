## .NET面试题汇总系列(一)：基础语法
1. 字符串中string str=null和string str=""和string str=string.Empty的区别  
string.Empty相当于“”,Empty是一个静态只读的字段。 string str="" ,初始化对象，并分配一个空字符串的内存空间 string str=null,初始化对象，不会分配内存空间

2. byte b = 'a'; byte c = 1; byte d = 'ab'; byte e = '啊'; byte g = 256; 这些变量有些错误是错再哪里?  
本题考查的是数据类型能承载数据的大小。
1byte =8bit，1个汉字=2个byte，1个英文=1个byte=8bit
所以bc是对的，deg是错的。'a'是char类型，a错误
java byte取值范围是-128~127, 而C#里一个byte是0~255
3. string和StringBuilder的区别,两者性能的比较  
都是引用类型，分配在堆上
StringBuilder默认容量是16，可以允许扩充它所封装的字符串中字符的数量.每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。
对于简单的字符串连接操作，在性能上stringbuilder不一定总是优于strin因为stringbulider对象的创建也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder的使用。从最后分析可以看出如果是相对较少的字符串拼接根本看不出太大差别。
Stringbulider的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分配操作，是不妥的实现方法。 参考链接：https://www.cnblogs.com/haofuqi/p/4826262.html
4. 什么是扩展方法？  
一句话解释，扩展方法使你能够向现有类型“添加”方法，无需修改类型
条件：按扩展方法必须满足的条件，1.必须要静态类中的静态方法2.第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法
建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现
使用：不能通过类名调用，直接使用类型来调用
5. byte a =255;a+=5;a的值是多少？
byte的取值范围是-2的8次方至2的8次方-1，-256至258，a+=1时，a的值时0，a+=5时，a的值是0，所以a+=5时，值是4

6. 什么是装箱和拆箱？
装箱就是隐式地将一个值类型转换成引用类型，如：
int i=0;
Syste.Object obj=i;
拆箱就是将引用类型转换成值类型，如：
int i=0;
System.Object obj=i;
int j=(int)obj;（将obj拆箱）
7. 值类型和引用类型的区别
值类型变量是直接包含值。将一个值类型变量赋给另一个值类型变量，是复制包含的值，默认值是0。
引用类型变量的赋值只复制对对象的引用，而不复制对象本身，默认值是null
值类型有整形、浮点型、bool、枚举。
引用类型有class、delegate、Object、string
值类型存储在栈中，引用类型存储在堆中
8. new关键字的作用
运算符：创建对象实例
修饰符：在派生类定义一个重名的方法，隐藏掉基类方法
约束：泛型约束定义，约束可使用的泛型类型,如：
public class ItemFactory<T> where T : IComparable, new()
   {
   }
9. int?和int有什么区别
int？为可空类型，默认值可以是null
int默认值是0
int?是通过int装箱为引用类型实现
10. C#中的委托是什么？
一句话解释就是：将方法当作参数传入另一个方法的参数。 .net中有很多常见的委托如：Func 、Action 作用：提高方法的扩展性

11. 用最有效的方法算出2乘以8等于几？
位运算是最快，使用的是位运算 逻辑左位移<<。 方法是2<<3相当于0000 0000 0000 0010 （2的16位int二进制）左移三位就是 0000 0000 0001 0000（16的二进制）

12. const和readonly有什么区别？
都可以标识一个常量。主要有以下区别：

1. 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在静态构造方法（必须是静态构造方法，普通构造方法不行）里赋值。
2. 修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段
3. const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。
4. const默认是静态的；而readonly如果设置成静态需要显示声明
5. 修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。
13. 现有一个整数number，请写一个方法判断这个整数是否是2的N次方  
    4（100）、5（101）、8（1000）、16（10000）  
取模运算： 用number%2==0可以判断，但是这个有点低级  
位运算：（使用位运算逻辑并，两个位上的都为1才是1，其余都是0，判断是否等于0）  
4&3相当于100&011 ，结果是000等于0，所以4是2的n次方  
5&4相当于101&100，结果是100不等于0，所以5不是2的n次方  
如果要问如果是2的N次方，这个N是多少？这该怎么算？  
    ```C#
    private static byte get(int n)
        {
            byte number = 1;
            while (n/2!=1)
            {
                n = n / 2;
                number += 1;
            }
            return number;
        }
    ```
14. CTS、CLS、CLR分别作何解释
CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。

CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。
CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。
CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。
15. 在.net中，配件的意思是？
程序集。（中间语言，源数据，资源，装配清单）

16. 分析下面代码，a、b的值是多少？
string strTmp = "a1某某某";
int a = System.Text.Encoding.Default.GetBytes(strTmp).Length;
int b = strTmp.Length;
分析：一个字母、数字占一个byte，一个中文占占两个byte，所以a=8,b=5

17. Strings = new String(“xyz”);创建了几个String Object?
两个对象，一个是“xyz”,一个是指向“xyz”的引用对象s。

18. 静态成员和非静态成员的区别
1.静态成员用statis修饰符声明，在类被实例化时创建，通过类进行访问
2.不带statis的变量时非静态变量，在对象被实例化时创建，通过对象进行访问，
3.静态方法里不能使用非静态成员，非静态方法可以使用静态成员
4.静态成员属于类，而不属于对象
19. c#可否对内存直接操作
C#在unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针，C#NET默认不运行带指针的，需要设置下，选择项目右键->属性->选择生成->“允许不安全代码”打勾->保存

20. short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
s1+1不能显式转换成short类型，可以修改为s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1正确

21. 什么是强类型，什么是弱类型？哪种更好些？为什么?
强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如javascript,vb,php等

22. using关键字的作用
1. 引用命名空间，也可using 别名
2. 释放资源，实现了IDisposiable的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源。
23. ref和out有什么区别
1. 都是按引用类型进行传递
2. 属性不是变量不能作为out、ref参数传递
3. ref参数必须初始化。out不需要初始化
4. 作用，当方法有多个返回值时，out非常有用
24. a.Equals(b)和a==b一样吗？
不一样，a==b仅仅表示a和b值相等，a.Equals(b)表示a与b一致

25. 下面这段代码求值
    ```C#
    class Class1
        {
            internal static int count = 0;
            static Class1()
            {
                count++;
            }
            public Class1()
            {
                count++;
            }
        }
        Class1 o1 = new Class1();
        Class1 o2 = new Class1();
      o1.count的值是多少？
    
    答案：3，静态 构造方法计算一次，两个实例化对象计算两次。
    ```

26. 关于构造函数说法正确的是哪个？
    1. 构造函数可以声明返回类型。  

    2.  构造函数不可以用private修饰  

    3.  构造函数必须与类名相同  
 
    4.  构造函数不能带参数  

    答案：3,构造函数必须与类名相同，可以传递多个传递，作用就是便于初始化对象成员，不能有任何返回类型  

27. Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?
Math.Round(11.5)=12  
Math.Round(-11.5)=-12  
28. &和&&的区别
* 相同点
  * &和&&都可作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，其结果才为true，否则，只要有一方为false，则结果为false。（ps：当要用到逻辑与的时候&是毫无意义，&本身就不是干这个的）

* 不同点
* if(loginUser!=null&&string.IsnullOrEmpty(loginUser.UserName))
  &&具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，对于上面的表达式，当loginUser为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。（ps：所以说当要用到逻辑与的时候&是毫无意义的）

* & 是用作位运算的。

* 总结
  * &是位运算，返回结果是int类型 &&是逻辑运算，返回结果是bool类型

29. i++和++i有什么区别？
    1. i++是先赋值，然后再自增；++i是先自增，后赋值。
    2. i=0，i++=0，++i=1； Console.WriteLine(++i==i++); 结果位true
30. as和is的区别    
    as在转换的同时判断兼容性，如果无法进行转换，返回位null（没有产生新的对象），as转换是否成功判断的依据是是否位null is只是做类型兼容性判断，并不执行真正的类型转换，返回true或false，对象为null也会返回false。
as比is效率更高，as只需要做一次类型兼容检查

## .NET面试题汇总系列(二)：面向对象
1. 什么是构造函数？
* 概念：构造函数的方法名与类型相同、没有返回类型

* 作用：完成对类的对象初始化

  * 创建一个类的新对象时，系统会自动调用该构造函数初始化新对象， 如果没有写定义，那么系统会自动提供一个不带任何参数的public 构造函数

2. class和struct的区别?
* 相同点 都可以实现接口

* 不同点

  1. class是引用类型，struct是值类型
  2. class允许继承、被继承，struct不允许，只能继承接口
  3. class可以初始化变量，struct不可以
  4. class可以有无参的构造函数，struct不可以，必须是有参的构造函数，而且在有参的构造函数必须初始化所有成员
* 使用场景

  1. Class比较适合大的和复杂的数据，表现抽象和多级别的对象层次时。
  2. Struct适用于作为经常使用的一些数据组合成的新类型，表示诸如点、矩形等主要用来存储数据的轻量级对象时，偏简单值。
  3. Struct有性能优势，Class有面向对象的扩展优势。
3. 简述一下面向对象的三大特性？
* 封装、继承、多态。
* 封装：是通过把对象的属性的实现细节隐藏起来，仅对外提供公共的访问方法。
* 继承：是通过子类继承基类、继承抽象类、继承接口实现的。
* 多态：是通过重写基类的override 方法、重写虚方法实现的。 好处是：方便维护、易扩展。 缺点是：比面向过程性能低。
4. 构造函数是否能被重写？
构造器Constructor不能被继承，因此不能重写，但可以被重载

5. 抽象类和接口有什么区别？
* 相同点：都不能直接实例化 
* 不同点：
  1. 抽象类用abstract修饰、接口用interface修饰
  2. 抽象类中的方法可以实现，也可以不实现，有抽象方法的类一定要用abstract修饰，接口中的方法不允许实现
  3. 抽象类只能单继承，接口支持多实现
  4. 抽象类有构造方法，接口不能有构造方法
  5. 接口只负责功能的定义，通过接口来规范类的，（有哪些功能），而抽象类即负责功能的定义有可以实现功能（实现了哪些功能）
  6. 类的执行顺序？
     * 执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法

7. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？
   * 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实现类，但前提是实现类必须有明确的构造函数。

8. 继承最大的好处？
   * 对父类成员进行重用，增加代码的可读性、灵活性。

9. 请说说引用和对象?
   * 对象和引用时分不开的，对象生成一个地址，放在堆里面，引用则指向这个地址，放在栈里面

10. 什么是匿名类，有什么好处？
    * 不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。

11. 重写和重载的区别?
* 重写方法：关键字用override修饰，派生类重写基类的方法，方法命名、返回类型，参数必须相同
* 重载方法：方法名必须相同，参数列表必须不相同，返回类型可以不相同。
* 作用：重写主要是实现面向对象的多态性、重载主要是实现实例化不同的对象
12. C#中有没有静态构造函数，如果有是做什么用的？
* 特点：静态构造函数既没有访问修饰符，也没有参数。在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数来初始化类。无法直接调用静态构造函数。在程序中，用户无法控制何时执行静态构造函数。 
* 用途：当类使用日志文件时，将使用这种构造函数向日志文件中写入项。

13. 怎样理解静态变量？静态成员和非静态成员的区别？
* 静态变量属于类，而不属于对象；并对所有对象所享；静态成员在加类的时候就被加载。

14. 属性能在接口中声明吗？
* 可以，不能有访问修饰符，不能初始化赋值。

15. 在项目中为什么使用接口？接口的好处是什么？什么是面向接口开发？
    * 接口是一种约束，描述类的公共方法/公共属性，不能有任何的实现
    * 好处是：结构清晰，类之间通信简单易懂，扩展性好，提高复用性。
    * 面向interface编程，原意是指面向抽象协议编程，实现者在实现时要严格按协议来办。
16. 什么时候用重载？什么时候用重写？
* 当一个类需要用不同的实现来做同一件事情，此时应该用重写，而重载是用不同的输入做同一件事情

17. 静态方法可以访问非静态变量吗？如果不可以为什么？
* 静态方法和非静态变量不是同一生命周期，静态方法属于类，非静态变量属于具体的对象，静态方法和具体的对象没有任何关联

18. 在.Net中所有可序列化的类都被标记为_?
* [serializable]

19. C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
* 一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质

20. 当使用new B()创建B的实例时，产生什么输出？
    ```C#
       using System;
        class A
        {
              public A()
              {
                    PrintFields();
              }
              public virtual void PrintFields(){}
          }
          class B:A
          {
               int x=1;
               int y;
               public B()
               {
                   y=-1;
               }
               public override void PrintFields()
               {
                   Console.WriteLine("x={0},y={1}",x,y);
               }
         }
    答：X=1,Y=0;
    ```

21. 能用foreach遍历访问的对象需要实现 ____接口或声明____方法的类型
* 答：IEnumerable 、 GetEnumerator。

## .NET/C#⾯试题汇总系列：集合、异常、泛型、LINQ、委托、EF！
1. IList 接⼝与List的区别是什么?
* IList 泛型接⼝是 Icollection 接⼝的⼦代，并且是所有⾮泛型列表的基接⼝。 
* Ilist 实现有三种类别：只读、固定⼤⼩、可变⼤⼩。 ⽆法修改只读 Ilist。 固定⼤⼩的 Ilist 不允许添加或移除元素，但允许修改现
  有元素。 可变⼤⼩的 Ilist 允许添加、移除和修改元素。
* IList 是个接⼝,定义了⼀些操作⽅法这些⽅法要你⾃⼰去实现，当你只想使⽤接⼝的⽅法时,这种⽅式⽐较
  好.他不获取实现这个接⼝的类的其他⽅法和字段，有效的节省空间．
* List 是个类型已经实现了IList 定义的那些⽅法。
2. 泛型的主要约束和次要约束是什么？-
*  当⼀个泛型参数没有任何约束时，它可以进⾏的操作和运算是⾮常有限的，因为不能对实参进⾏任何类型上的保证，
   这时候就需要⽤到泛型约束。泛型的约束分为：主要约束和次要约束，它们都使实参必须满⾜⼀定的规范，
   C#编译器在编译的过程中可以根据约束来检查所有泛型类型的实参并确保其满⾜约束条件。
* 主要约束
   * ⼀个泛型参数⾄多拥有⼀个主要约束，主要约束可以是⼀个引⽤类型、class或者struct。如果指定⼀个引⽤类型（class），
     那么实参必须是该类型或者该类型的派⽣类型。相反，struct则规定了实参必须是⼀个值类型。下⾯的代码展示了泛型参数主要约束：
    ```C#
     public class ClassT1<T> where T : Exception
     {
        private T myException;
        public ClassT1(T t)
        {
            myException = t;
        }
        public override string ToString()
        {
            // 主要约束保证了myException拥有source成员
            return myException.Source;
        }
    }
    public class ClassT2<T> where T : class
    {
        private T myT;
        public void Clear()
        {
            // T是引⽤类型，可以置null
            myT = null;
        }
    }
    public class ClassT3<T> where T : struct
    {
        private T myT;
        public override string ToString()
        {
            // T是值类型，不会发⽣NullReferenceException异常
            return myT.ToString();
        }
    }
    ```
* 次要约束
  * 次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型，可以有0到⽆限的次要约束，次要约束规定了实参必须实现所有的次要约束中规定的接⼝。
    次要约束与主要约束的语法基本⼀致，区别仅在于提供的不是⼀个引⽤类型⽽是⼀个或多个接⼝。例如我们为上⾯代码中的ClassT3增加⼀个次要约束：
    ```C#
    public class ClassT3<T> where T : struct, IComparable
    {
        ......
    }
    ```
3. 如何把⼀个array复制到arrayist⾥?
    ```C#
    foreach( object arr in array)
    {
        arrayist.Add(arr);
    }
    ```
4. List, Set, Map是否继承⾃Collection接⼝?
List，Set是，Map不是
5. Set⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?
* Set⾥的元素是不能重复的，那么⽤iterator()⽅法来区分重复与否。
* equals()是判读两个Set是否相等。equals()和==⽅法决定引⽤值是否指向同⼀对像，equals()在类中被覆盖，
  为的是当两个分离的对象的内容和类型相配的话，返回真值。
6. 有50万个int类型的数字，现在需要判断⼀下⾥⾯是否存在重复的数字，请你简要说⼀下思路。
* 使⽤C#的List集合⾃带的去重⽅法，例如 Distinct()，GroupBy()等。
* 利⽤ Dictionary 的Key值唯⼀的特性，HashSet 元素值唯⼀的特性 进⾏判断。
7. 数组有没有length()这个⽅法? String有没有length()这个⽅法 ？
* 数组没有length()这个⽅法，有length的属性。String有有length()这个⽅法。
8. ⼀个整数List中取出最⼤数（找最⼤值）。不能⽤Max⽅法。
    ```C#
    private static int GetMax(List<int> list)
    {
        int max = list[0];
        for (int i = 0; i < list.Count; i++)
        {
            if (list[i]>max)
            {
                max = list[i];
            }   
        }
        return max;
    }
    ```
9. C#异常类有哪些信息？
* C#中，所有异常都继承⾃System.Exception类，Exception类定义了C#异常应该具有的信息和⽅法。值得注意的属性有：
    ```C#
    public virtual string Message { get; }// 错误的信息，⽂字描述
    public virtual string StackTrace { get; }// 发⽣异常的调⽤堆栈信息
    public System.Reflection.MethodBase TargetSite { get; }//引发这个错误的⽅法
    public Exception InnerException { get; }// ⼦异常
    ```
10. 如何创建⼀个⾃定义异常？
* 根据类继承原则和异常处理原则，我们可以使⽤以下⽅式来⾃定义⼀个类：
    ```C#
    public class CustomException:Exception{}
    ```
11. 利⽤IEnumerable实现斐波那契数列⽣成?
    ```C#
    IEnumerable<int> GenerateFibonacci(int n)
    {
        if (n >= 1) yield return 1;
    
        int a = 1, b = 0;
        for (int i = 2; i <= n; ++i)
        {
            int t = b;
            b = a;
            a += t;
            yield return a;
        }
     }
     ```
12. 请利⽤ foreach 和 ref 为⼀个数组中的每个元素加 1
* 注意 foreach 不能⽤ var ，也不能直接⽤ int ，需要 ref int ，注意 arr 要转换为 Span 。
    ```C#
    int[] arr = { 1, 2, 3, 4, 5};
    Console.WriteLine(string.Join(",", arr)); // 1,2,3,4,5
    foreach (ref int v in arr.AsSpan())
    {
        v++;
    }
    Console.WriteLine(string.Join(",", arr)); // 2,3,4,5,6
    ```
13. 如何针对不同的异常进⾏捕捉？
    ```C#
    public class Program
    {
        public static void Main(string[] args)
        {
            Program p = new Program();
            p.RiskWork();
    
            Console.ReadKey();
        }
    
        public void RiskWork()
        {
            try
            {
                // ⼀些可能会出现异常的代码
            }
            catch (NullReferenceException ex)
            {
                HandleExpectedException(ex);
            }
            catch (ArgumentException ex)
            {
                HandleExpectedException(ex);
            }
            catch (FileNotFoundException ex)
            {
                HandlerError(ex);
            }
            catch (Exception ex)
            {
                HandleCrash(ex);
            }
        }
        //这⾥处理预计可能会发⽣的，不属于错误范畴的异常
        private void HandleExpectedException(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
        }
    
        // 这⾥处理在系统出错时可能会发⽣的，⽐较严重的异常
        private void HandlerError(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
            // 严重的异常需要抛到上层处理
            throw ex;
        }
    
        // 这⾥处理可能会导致系统崩溃时的异常
        private void HandleCrash(Exception ex)
        {
            // 这⾥可以借助log4net写⼊⽇志
            Console.WriteLine(ex.Message);
            // 关闭当前程序
            System.Threading.Thread.CurrentThread.Abort();
        }
    }
    ```
14. 如何避免类型转换时的异常？
* 其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类引⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。
* 当⼀个不正确的类型转换发⽣时，会产⽣InvalidCastException异常，有时我们会⽤try-catch块做⼀些尝试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源的机制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较⾼，并且在尝试性类型转换时，这些信息都没有意义。在.NET中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。
  1. is 只负责检查类型的兼容性，并返回结果：true 和 false。→ 进⾏类型判断;
    ```C#
    public static void Main(string[] args)
    {
        object o = new object();
        // 执⾏类型兼容性检查
        if(o is ISample)
        {
        // 执⾏类型转换
        ISample sample = (ISample)o;
        sample.SampleShow();
        }
        Console.ReadKey();
     }
    ```
  2. as 不仅负责检查兼容性还会进⾏类型转换，并返回结果，如果不兼容则返回 null 。→ ⽤于类型转型
    ```c#
    public static void Main(string[] args)
    {
        object o = new object();
        // 执⾏类型兼容性检查
        ISample sample = o as ISample;
        if(sample != null)
        {
            sample.SampleShow();
        }
        Console.ReadKey();
     }
    ``` 
  * 两者的共同之处都在于：不会抛出异常！综上⽐较，as 较 is 在执⾏效率上会好⼀些，在实际开发中应该
    量才⽽⽤，在只进⾏类型判断的应⽤场景时，应该多使⽤ is ⽽不是 as。
15. Serializable特性有什么作⽤？
  * 通过上⾯的流类型可以⽅便地操作各种字节流，但是如何把现有的实例对象转换为⽅便传输的字节流，就
    需要使⽤序列化技术。对象实例的序列化，是指将实例对象转换为可⽅便存储、传输和交互的流。在.NET
    中，通过Serializable特性提供了序列化对象实例的机制，当⼀个类型被申明为Serializable后，它就能被
    诸如BinaryFormatter等实现了IFormatter接⼝的类型进⾏序列化和反序列化。
16. 委托是什么?
  * 委托是寻址的.NET版本。在C++中，函数指针只不过是⼀个指向内存位置的指针，它不是类型安全的。我
    们⽆法判断这个指针实际指向什么，像参数和返回类型等项久更⽆从知晓了。
  * ⽽.NET委托完全不同，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对⽅法的
    引⽤，也可以包含对多个⽅法的引⽤。
17. 如何⾃定义委托？
  * 声明⼀个委托类型，它的实例引⽤⼀个⽅法，该⽅法获取⼀个int参数，返回void。
  > public delegate void Feedback(int num);
  * 理解委托的⼀个要点是它们的安全性⾮常⾼。在定义委托时，必须给出它所表示的⽅法的签名和返回类型
    等全部细节。
  * 理解委托的⼀种⽐较好的⽅式是把委托当作这样⼀件事情：它给⽅法的签名和返回类型指定名称.
  * 其语法类似于⽅法的定义，需要在定义⽅法的前⾯加上delegate关键字。定义委托基本上就是定义⼀个新
    的类，所以可以在任何地⽅定义类的相同地⽅定义委托，也就是说，可以在另⼀个类的内部定义，也可以
    在任何类的外部定义，还可以在名称控件中把委托定义为定义为顶层对象。访问修饰符可以是
    public/private/protected等。
18. NET默认的委托类型有哪⼏种？
    1. Action < T >
       * 泛型Action委托表示引⽤⼀个void返回类型的⽅法。这个委托类存在16种重载⽅法。
    2. Func< T >
       * Func调⽤带返回类型的⽅法。有16种重载⽅法
       * 例如Func委托类型可以调⽤带返回类型且⽆参数的⽅法，Func<in T,out TResult>委托类型调⽤带有4个
         参数和⼀个返回类型的⽅法。
19. 什么是泛型委托？
  * Action就是泛型委托。
  * 注意事项：
    1. 建议尽量使⽤这些委托类型，⽽不是在代码中定义更多的委托类型。这样可以减少系统中的类型数⽬，同
      时简化编码
    2. 如果需要使⽤ref或out关键字，以传引⽤的⽅式传递⼀个参数，就可能不得不定义⾃⼰的委托：
      delegate void Test(ref int i)
    3. 如果委托要通过C#的params关键字获取可变数量的额参数，要为委托的任何桉树指定默认值，或者要
      对委托的泛型类型参数进⾏约束，也必须定义⾃⼰的委托类型
      delegate void EventHandler(Object sender, TEventArgs e)
      where TEventArgs : EventArgs;
    4. 使⽤获取泛型实参和返回值的委托时，可利⽤逆变与协变。逆变：⽗类转换为⼦类；协变：⼦类转换为
      ⽗类。
20. 什么是匿名⽅法?
  * 匿名⽅法是⽤作委托的参数的⼀段代码。
      ```C#
        //匿名⽅法,例1
        Func<int, int> anon = delegate(int i)
        {
            i = i+1;
            return i;
        };
        //输出2
        Console.WriteLine(anon(1));
        //匿名⽅法,例2
        Action<int> anon2 = delegate(int i)
        {
            i = i + 1;
        };
        //输出2
        Console.WriteLine(anon(1));
      ```
21. 什么是闭包？
  * 通过Lambda表达式可以访问Lambda表达式块外部的变量，这成为闭包。
  * 当引⽤外部变量时，需要注意，外部变量变化时，lambda表达式的结果也可能会随着外部变量变化⽽变
    化。
  * 如下⾯的例⼦：
      ```C#
        int y = 5;
        Func<int, int> lambda = x => x + y;
        Console.WriteLine(lambda(1));
        y = 10;
        Console.WriteLine(lambda(1));
      ```
22. EF(Entity Framework)是什么？
  * 实体框架EF是http://ADO.NET中的⼀组⽀持开发⾯向数据的软件应⽤程序的技术，是微软的⼀个ORM框
    架。
  * 主要有三种⽅式:
    * Database FirstDatabase First”模式:我们称之为“数据库优先”，前提是你的应⽤已经有相应的数据库，你可以使⽤EF设计⼯具根据数据库⽣成
      数据数据类，你可以使⽤Visual Studio模型设计器修改这些模型之间对应关系。
    * Model FirstModel First:我们称
      之为“模型优先”，这⾥的模型指的是“ADO.NET Entity Framework Data Model”，此时你的应⽤并没有
      设计相关数据库，在Visual Studio中我们通过设计对于的数据模型来⽣成数据库和数据类。
    * Code FirstCode First:我们称之为“代码优先”模式，是从EF4.1开始新建加⼊的功能。
    * 使⽤Code First模式进⾏EF开发时开发⼈员只需要编写对应的数据类（其实就是领域模型的实现过程），
      然后⾃动⽣成数据库。这样设计的好处在于我们可以针对概念模型进⾏所有数据操作⽽不必关⼼数据的存
      储关系，使我们可以更加⾃然的采⽤⾯向对象的⽅式进⾏⾯向数据的应⽤程序开发。
23. 什么是ORM?
  * ORM指的是⾯向对象的对象模型和关系型数据库的数据结构之间的互相转换。(表实体跟表之间的相互转换)
  * ORM框架有很多，EF框架是ORM框架的其中⼀种，是实现了ORM思想的框架。  
    O=>表实体  
    M=>映射关系  
    R=>数据库.表
24. 为什么⽤EF⽽不⽤原⽣的ADO.NET?
  * 极⼤的提⾼开发效率:EF是微软⾃⼰的产品,开发中代码都是强类型的, EF代码效率⾮常⾼,⾃动化程度⾮常⾼,命令式的编程.
  * EF提供的模型设计器⾮常强⼤,不仅仅带来了设计数据库的⾰命,也附带来的⾃动化模型代码的功能也极⼤的提⾼开发和架构设计的效率.
  * EF跨数据⽀持的是ORM框架主要功能点之⼀,带来的是可以通过仅仅改变配置就可以做到跨数据库的能⼒. 
25. 如何提⾼LINQ性能问题？
    * 提升从数据库中拿数据的速度，可以参考以下⼏种⽅法：
    1. 在数据库中的表中定义合适的索引和键
    2. 只获得你需要的列（使⽤ViewModel或者改进你的查询）和⾏（使⽤IQueryable）
    3. 尽可能使⽤⼀条查询⽽不是多条
    4. 只为了展示数据，⽽不进⾏后续修改时，可以使⽤AsNoTracking。它不会影响⽣成的SQL，但它可以令系统少维护很多数据，从⽽提⾼性能
    5. 使⽤Reshaper等⼯具，它可能会在你写出较差的代码时给出提醒.
26. 什么是协变和逆变?
27. 什么是IEnumerable？
    * IEnumerable及IEnumerable的泛型版本IEnumerable是⼀个接⼝，它只含有⼀个⽅法GetEnumerator。
      Enumerable这个静态类型含有很多扩展⽅法，其扩展的⽬标是IEnumerable。
    * 实现了这个接⼝的类可以使⽤Foreach关键字进⾏迭代（迭代的意思是对于⼀个集合，可以逐⼀取出元素
      并遍历之）。实现这个接⼝必须实现⽅法GetEnumerator。
28. IEnumerable的缺点有哪些？
    * IEnumerable功能有限，不能插⼊和删除。
    * 访问IEnumerable只能通过迭代，不能使⽤索引器。迭代显然是⾮线程安全的，每次IEnumerable都会⽣成新的IEnumerator，从⽽形成多个互相不影响的迭代过程。
    * 在迭代时，只能前进不能后退。新的迭代不会记得之前迭代后值的任何变化。
29. 延迟执⾏ (Lazy Loading)是什么？
    * ⼤部分LINQ语句是在最终结果的第⼀个元素被访问的时候（即在foreach中调⽤MoveNext⽅法）才真正
      开始运算的，这个特点称为延迟执⾏。⼀般来说，返回另外⼀个序列（通常为IEnumerable或
      IQueryable）的操作，使⽤延迟执⾏，⽽返回单⼀值的运算，使⽤⽴即执⾏。
    * IEnumerable是延迟执⾏的，当没有触发执⾏时，就不会进⾏任何运算。Select⽅法不会触发LINQ的执
      ⾏。⼀些触发的⽅式是：foreach循环，ToList，ToArray，ToDictionary⽅法等. 
30. LINQ可视化⼯具简单介绍⼀下？
    * LINQPad工具可以连接到已经存在的数据库（不过就仅限微软的SQL Server系，如果要连接到其
    他类型的数据库则需要安装插件）。某种程度上可以代替SQL Management Studio，是使⽤SQL
    Management Studio作为数据库管理软件的码农的强⼒⼯具，可以⽤于调试和性能优化（通过改善编译后
    的SQL规模）。
    * LINQPad⽀持使⽤SQL或C#语句（点标记或查询表达式）进⾏查询。你也可以通过点击橙⾊圈内的各种不
      同格式，看到查询表达式的各种不同表达⽅式：
      * Lambda：查询表达式的Lambda表达式版本，
      * SQL：由编译器转化成的SQL，通常这是我们最关⼼的部分，
      * IL：IL语⾔
31. LINQ to Object和LINQ to SQL有何区别？
    * LINQ to SQL可以将查询表达式转换为SQL语句，然后在数据库中执⾏。相⽐LINQ to Object，则是将查
    询表达式直接转化为Enumerable的⼀系列⽅法，最终在C#内部执⾏。LINQ to Object的数据源总是实现
    IEnumerable（所以不如叫做LINQ to IEnumerable），相对的，LINQ to SQL的数据源总是实现
    IQueryable并使⽤Queryable的扩展⽅法。
    * 将查询表达式转换为SQL语句并不保证⼀定可以成功. 
32. 除了EF，列举出你知道的ORM框架
    * dapper EntityFramework、 EJB、Hibernate、IBATIS、TopLink、OJB
33. 如何如何获取EF⽣成的Sql脚本
    1. 可以调试起来通过SqlServerProfiler 来获取Sql 
    2. EF Dbcontext 注册⽇志事件输出⽇志查看Sql
34. 在哪些类型额项⽬中你会选择EF? 为什么？
    * EF主要是以⾯向对象的思想来做数据库数据操作，对Sql语句能⼒没什么要
    求，开发使⽤效率⾼！便于上⼿，⼀般来说，使⽤EF框架，肯定会⽐直接使⽤ADO.NET，消耗的时间多⼀
    些。 所以在⼀般企业级开发，管理型系统，对数据性能要求不是特别⾼的情况下，优先选择EF,这样可以
    ⼤⼤的推进开发效率！如果像⼀些互联⽹项⽬中，对性能要求精度很⾼！可以另外做技术选型，选择原⽣
    ADO.NET。
35. 请说明EF中映射实体对象的⼏种状态？
    * Detached：该实体未由上下⽂跟踪。刚使⽤新运算符或某个 System.Data.Entity.DbSet Create ⽅法创
    建实体后，实体就处于此状态。
    * Unchanged：实体将由上下⽂跟踪并存在于数据库中，其属性值与数据库中的值相同。
    * Added：实体将由上下⽂跟踪，但是在数据库中还不存在。
    * Deleted：实体将由上下⽂跟踪并存在于数据库中，但是已被标记为在下次调⽤ SaveChanges 时从数据
    库中删除。
    * Modified：实体将由上下⽂跟踪并存在于数据库中，已修改其中的⼀些或所有属性值。
36. 如果实体名称和数据库表名不⼀致，该如何处理？
    * 实体名称和数据库表名称不⼀致：可以通过使⽤TableAttribute 特性； 
37. 泛型的优点有哪些？
    * 代码的可重⽤性。⽆需从基类型继承，⽆需重写成员。
    * 扩展性好。
    * 类型安全性提⾼。 泛型将类型安全的负担从你那⾥转移到编译器。 没有必要编写代码来测试正确的数据类
    型，因为它会在编译时强制执⾏。 降低了强制类型转换的必要性和运⾏时错误的可能性。 
    * 性能提⾼。泛型集合类型通常能更好地存储和操作值类型，因为⽆需对值类型进⾏装箱。
38. try {}⾥有⼀个return语句，那么紧跟在这个try后的finally {}⾥的code会不会被执⾏，什么时候被执⾏，在return前还是后?
    * 会执⾏，在return前执⾏。
39. C# 中的异常类有哪些？
    * C# 异常是使⽤类来表示的，异常类主要是直接或间接地派⽣于 System.Exception 类。
    * System.ApplicationException 和 System.SystemException 类是派⽣于 System.Exception 类的异常
    类。
    * System.ApplicationException 类⽀持由应⽤程序⽣成的异常，所以我们⾃⼰定义的异常都应派⽣⾃该
    类。
    * System.SystemException 类是所有预定义的系统异常的基类。
    * System.IO.IOException  ⽤于处理 I/O 错误(读写⽂件)。
    * System.IndexOutOfRangeException ⽤于处理当⽅法指向超出范围的数组索引时⽣成的错误。
    * System.ArrayTypeMismatchException  ⽤于处理当数组类型不匹配时⽣成的错误。
    * System.NullReferenceException  ⽤于处理当依从⼀个空对象时⽣成的错误。
    * System.DivideByZeroException ⽤于处理当除以零时⽣成的错误。例如：100/0就会报这个错误。
    * System.InvalidCastException  ⽤于处理在类型转换期间⽣成的错误。
    * System.OutOfMemoryException  ⽤于处理空闲内存不⾜⽣成的错误。
    * System.StackOverflowException  ⽤于处理栈溢出⽣成的错误。
40. 泛型有哪些常⻅的约束？
    * 泛型约束 public void GetEntity() where T:class
    * where T :struct //约束T必须为值类型
    * where K : class //约束K必须为引⽤类型
    * where V : IComparable //约束V必须是实现了IComparable接⼝
    * where W : K //要求W必须是K类型，或者K类型的⼦类
    * where X :class ,new () // 或者写出 new class();X必须是引⽤类型，并且要有⼀个⽆参的构造函数（对于⼀个类型有多有约束，中间⽤逗号隔开）
41. Collection和Collections的区别？
    * Collection 是集合类的上级接⼝，Collections 是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实
    现对各种集合的搜索，排序，线程安全化操作。
42. 能⽤foreach 遍历访问的对象的要求？
    * 需要实现IEnumerable接⼝或声明GetEnumerator⽅法的类型。
43. 说出五个集合类？
    * List：泛型类；
    * Stack：堆栈，后进先出的访问各个元素
    * Dictionary<TKey, TValue>：字典类，key是区分⼤⼩写；value⽤于存储对应于key的值
    * HashSet：此集合类中不能有重复的⼦元素
    * SortedList<TKey, TValue>：排序列表，key是排好序的数组。
44. C#可否对内存进⾏直接的操作？
    * C#在Unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针。
      1. 在 Visual Studio 开发环境中设置/unsafe（启⽤不安全模式)编译器选项  
        打开项⽬的“属性”⻚。  
        单击“⽣成”属性⻚。 
        选中“允许不安全代码”复选框。  
      2. unsafe关键字表示不安全上下⽂，该上下⽂是任何涉及指针的操作所必需的。  
        可以在类型或成员的声明中使⽤ unsafe修饰符。 
         因此，类型或成员的整个正⽂范围均被视为不安全上下⽂。例如，以下是⽤ unsafe 修饰符声明的⽅法：
      ```C#
       unsafe static void FastCopy(byte[] src, byte[] dst, int count)
       {
           // Unsafe context: can use pointers here.
       }
      ```
      不安全上下⽂的范围从参数列表扩展到⽅法的结尾，因此指针在以下参数列表中也可以使⽤：
      ```C#
       unsafe static void FastCopy ( byte* ps, byte* pd, int count )
       {...}
      ```
      还可以使⽤不安全块从⽽能够使⽤该块内的不安全代码。例如：
      ```C#
       unsafe
       {
           // Unsafe context: can use pointers here.
       }
      ```
      若要编译不安全代码，必须指定 /unsafe编译器选项。
      ⽆法通过公共语⾔运⾏库验证不安全代码。
45. HashMap和Hashtable区别
    Collection是集合类的上级接⼝，Collections是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实现
    对各种集合的搜索，排序，线程安全化操作。

## .NET/C#⾯试题汇总系列：多线程
1. 根据线程安全的相关知识，分析以下代码，当调⽤test⽅法时i>10时是否会引起死锁?并简
要说明理由。
    ```C#
       public void test(int i)
       {
       lock(this)
       {
       if (i>10)
       {
       i--;
       test(i);
       }
       }
       }
    ```
   * 不会发⽣死锁，（但有⼀点int是按值传递的，所以每次改变的都只是⼀个副本，因此不会出现死锁。但如
     果把int换做⼀个object，那么死锁会发⽣）
2. 描述线程与进程的区别？
   * 线程(Thread)与进程（Process）⼆者都定义了某种边界，不同的是进程定义的是应⽤程序与应⽤程序之
   间的边界，不同的进程之间不能共享代码和数据空间，⽽线程定义的是代码执⾏堆栈和执⾏上下⽂的边
   界。⼀个进程可以包括若⼲个线程，同时创建多个线程来完成某项任务，便是多线程。
   * ⽽同⼀进程中的不同线程共享代码和数据空间。⽤⼀个⽐喻来说，如果⼀个家庭代表⼀个进程，在家庭内
   部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进⾏积累，同时也有权利对家庭财富进
   ⾏消费，当⾯对⼀个任务的时候，家庭也可以派出⼏个成员来协同完成，⽽家庭之外的⼈则没有办法直接
   消费不属于⾃⼰家庭的财产.
3. Windows单个进程所能访问的最⼤内存量是多少？它与系统的最⼤虚拟内存⼀样吗？这对于系统设计有什么影响？
   * 这个需要针对硬件平台，公式为单个进程能访问的最⼤内存量=2的处理器位数次⽅/2，⽐如通常情况下，
   32位处理器下，单个进程所能访问的最⼤内存量为:232 /2 = 2G 。单个进程能访问的最⼤内存量是最⼤
   虚拟内存的1/2，因为要分配给操作系统⼀半虚拟内存。
4. using() 语法有⽤吗？什么是IDisposable?
   * 有⽤，实现了IDisposable的类在using中创建，using结束后会⾃定调⽤该对象的Dispose⽅法，释放资
   源。
5. 前台线程和后台线程有什么区别？
   * 通过将 Thread.IsBackground 属性设置为 true，就可以将线程指定为后台线程
   * 前台线程： 应⽤必须结束掉所有的前台线程才能结束程序，只要有⼀个前台线程没退出进程就不会⾃动退
   出，当然线程是依附在进程上的，所以你直接把进程KO掉了的话⾃然所有前台线程也会退出。
   * 后台线程： 进程可以不考虑后台直接⾃动退出，进程⾃动退出后所有的后台线程也会⾃动销毁。
6. 什么是互斥？
   * 当多个线程访问同⼀个全局变量，或者同⼀个资源(⽐如打印机)的时候，需要进⾏线程间的互斥操作来保证
   访问的安全性。
7. 如何查看和设置线程池的上下限?
   * 线程池的线程数是有限制的，通常情况下，我们⽆需修改默认的配置。但在⼀些场合，我们可能需要了解
   线程池的上下限和剩余的线程数。线程池作为⼀个缓冲池，有着其上下限。在通常情况下，当线程池中的
   线程数⼩于线程池设置的下限时，线程池会设法创建新的线程，⽽当线程池中的线程数⼤于线程池设置的
   上限时，线程池将销毁多余的线程。
   * PS：在.NET Framework 4.0中，每个CPU默认的⼯作者线程数量最⼤值为250个，最⼩值为2个。⽽IO
   线程的默认最⼤值为1000个，最⼩值为2个。
   * 在.NET中，通过 ThreadPool 类型提供的5个静态⽅法可以获取和设置线程池的上限和下限，同时它还额
   外地提供了⼀个⽅法来让程序员获知当前可⽤的线程数量，下⾯是这五个⽅法的签名:
     1. static void GetMaxThreads(out int workerThreads, out int completionPortThreads)
     2. static void GetMinThreads(out int workerThreads, out int completionPortThreads)
     3. static bool SetMaxThreads(int workerThreads, int completionPortThreads)
     4. static bool SetMinThreads(int workerThreads, int completionPortThreads)
     5. static void GetAvailableThreads(out int workerThreads, out int completionPortThreads)
8. Task状态机的实现和⼯作机制是什么？
   * CPS全称是Continuation Passing Style，在.NET中，它会⾃动编译为： 
     1. 将所有引⽤的局部变量做成
     闭包，放到⼀个隐藏的状态机的类中； 
     2. 将所有的await展开成⼀个状态号，有⼏个await就有⼏个状态号； 
     3. 每次执⾏完⼀个状态，都重复回调状态机的MoveNext⽅法，同时指定下⼀个状态号； 4.
     MoveNext⽅法还需处理线程和异常等问题。
9. await的作⽤和原理，并说明和GetResult()有什么区别？
   * 从状态机的⻆度出发，await的本质是调⽤Task.GetAwaiter()的UnsafeOnCompleted(Action)回调，并
   指定下⼀个状态号。
   * 从多线程的⻆度出发，如果await的Task需要在新的线程上执⾏，该状态机的MoveNext()⽅法会⽴即返
   回，此时，主线程被释放出来了，然后在UnsafeOnCompleted回调的action指定的线程上下⽂中继续
   MoveNext()和下⼀个状态的代码。
   * ⽽相⽐之下，GetResult()就是在当前线程上⽴即等待Task的完成，在Task完成前，当前线程不会释放。
   注意：Task也可能不⼀定在新的线程上执⾏，此时⽤GetResult()或者await就只有会不会创建状态机的区
   别了。
10. Task和Thread有区别吗？
    * Task和Thread都能创建⽤多线程的⽅式执⾏代码，但它们有较⼤的区别。Task较新，发布于.NET 4.5，
    能结合新的async/await代码模型写代码，它不⽌能创建新线程，还能使⽤线程池（默认）、单线程等⽅
    式编程，在UI编程领域，Task还能⾃动返回UI线程上下⽂，还提供了许多便利API以管理多个Task。
11. 多线程有什么⽤？
    1. 发挥多核CPU的优势：
    随着⼯业的进步，现在的笔记本、台式机乃⾄商⽤的应⽤服务器⾄少也都是双核的，4核、8核甚⾄16核的
    也都不少⻅，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核
    CPU上所谓的”多线程”那是假的多线程，同⼀时间处理器只会处理⼀段逻辑，只不过线程之间切换得⽐较
    快，看着像多个线程”同时”运⾏罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时
    ⼯作，多线程，可以真正发挥出多核CPU的优势来，达到充分利⽤CPU的⽬的。
    2. 防⽌阻塞：
    从程序运⾏效率的⻆度来看，单核CPU不但不会发挥出多线程的优势，反⽽会因为在单核CPU上运⾏多线
    程导致线程上下⽂的切换，⽽降低程序整体的效率。但是单核CPU我们还是要应⽤多线程，就是为了防⽌
    阻塞。试想，如果单核CPU使⽤单线程，那么只要这个线程阻塞了，⽐⽅说远程读取某个数据吧，对端迟
    迟未返回⼜没有设置超时时间，那么你的整个程序在数据返回回来之前就停⽌运⾏了。多线程可以防⽌这
    个问题，多条线程同时运⾏，哪怕⼀条线程的代码执⾏读取数据阻塞，也不会影响其它任务的执⾏。
    3. 便于建模：
    这是另外⼀个没有这么明显的优点了。假设有⼀个⼤的任务A，单线程编程，那么就要考虑很多，建⽴整个
    程序模型⽐较麻烦。但是如果把这个⼤的任务A分解成⼏个⼩任务，任务B、任务C、任务D，分别建⽴程
    序模型，并通过多线程分别运⾏这⼏个任务，那就简单很多了。
12. 两个线程交替打印0~100的奇偶数
       * 这道题就是说有两个线程，⼀个名为偶数线程，⼀个名为奇数线程，偶数线程只打印偶数，奇数线程只打
       印奇数，两个线程按顺序交替打印。
       ```C#
       public class ThreadExample
       {
            ///<summary>
            ///两个线程交替打印0~100的奇偶数
            ///</summary>
            public static void PrintOddEvenNumber
            {
                varwork = newTheadWorkTest;
                varthread1 = newThread(work.PrintOddNumer) { Name = "奇数线程"};
                varthread2 = newThread(work.PrintEvenNumber) { Name = "偶数线程"};
                thread1.Start;
                thread2.Start;
            }
       }
    
       public class TheadWorkTest
       {
    
            private static readonly AutoResetEvent oddAre = newAutoResetEvent(false);
    
            private static readonly AutoResetEvent evenAre = newAutoResetEvent(false);
    
            public void PrintOddNumer
            {
                oddAre.WaitOne;
                for( var0; i < 100; i++ )
                {
                    if(i % 2!= 1) continue;
                    Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");
                    evenAre.Set;
                    oddAre.WaitOne;
                }
            }
    
            public void PrintEvenNumber
            {
                    for( vari = 0; i < 100; i++ )
                    {
                        if(i % 2!= 0) continue;
                        Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");
                        oddAre.Set;
                        evenAre.WaitOne;
                    }
            }
       }
       ```
13. 为什么GUI不⽀持跨线程调⽤?有什么解决⽅法？
  * 因为GUI应⽤程序引⼊了⼀个特殊的线程处理模型，为了保证UI控件的线程安全，这个线程处理模型不允许其他⼦线程跨线程访问UI元素。解决⽅法⽐较多的：
    * 利⽤UI控件提供的⽅法，Winform是控件的Invoke⽅法，WPF中是控件的Dispatcher.Invoke⽅法；
    * 使⽤BackgroundWorker；
    * 使⽤GUI线程处理模型的同步上下⽂SynchronizationContext来提交UI更新操作
14. 说说常⽤的锁，lock是⼀种什么样的锁？
    * 常⽤的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是⼀个混
    合锁，其实质是Monitor
15. lock为什么要锁定⼀个参数（可否为值类型？）参数有什么要求？
    * lock的锁对象要求为⼀个引⽤类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不⼀
    样，会导致锁定⽆效。
    * 对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向⼀个真正的锁（同步
    块），这个锁（同步块）会被复⽤
16. 多线程和异步的区别和联系?
    * 多线程是实现异步的主要⽅式之⼀，异步并不等同于多线程。实现异步的⽅式还有很多，⽐如利⽤硬件的
    特性、使⽤进程或纤程等。
    * 在.NET中就有很多的异步编程⽀持，⽐如很多地⽅都有Begin 、End 的⽅法，就是⼀种异步编程⽀持，她
    内部有些是利⽤多线程，有些是利⽤硬件的特性来实现的异步编程。
17. 线程池的有点和不⾜?
    * 优点：减⼩线程创建和销毁的开销，可以复⽤线程；也从⽽减少了线程上下⽂切换的性能损失；在GC回收
    时，较少的线程更有利于GC的回收效率。
    * 缺点：线程池⽆法对⼀个线程有更多的精确的控制，如了解其运
    ⾏状态等；不能设置线程的优先级；加⼊到线程池的任务（⽅法）不能有返回值；对于需要⻓期运⾏的任
    务就不适合线程池。
18. Mutex和lock有什么不同？⼀般⽤哪⼀种⽐较好？
    * Mutex是⼀个基于内核模式的互斥锁，⽀持锁的递归调⽤，⽽Lock是⼀个混合锁，⼀般建议使⽤Lock更
    好，因为lock的性能更好。
19. ⽤双检锁实现⼀个单例模式Singleton。
       ```C#
       public static class Singleton<T> where T : class,new()
       {
           private static T _Instance;
           private static object _lockObj = new object();

           /// <summary>
           /// 获取单例对象的实例
           /// </summary>
           public static T GetInstance()
           {
               if (_Instance != null) return _Instance;
               lock (_lockObj)
               {
                   if (_Instance == null)
                   {
                       var temp = Activator.CreateInstance<T>();
                       System.Threading.Interlocked.Exchange(ref _Inance, temp);
                   }
               }   
               return _Instance;
           }
        }
       ```
20. Thread 类有哪些常⽤的属性和⽅法？
    * 属性：
      * CurrentContext：获取线程正在其中执⾏的当前上下⽂。
      * CurrentCulture：获取或设置当前线程的区域性。
      * CurrentPrincipal：获取或设置线程的当前负责⼈（对基于⻆⾊的安全性⽽⾔）。
      * CurrentThread：获取当前正在运⾏的线程。
      * CurrentUICulture：获取或设置资源管理器使⽤的当前区域性以便在运⾏时查找区域性特定的资源。
      * IsBackground：获取或设置⼀个值，该值指示某个线程是否为后台线程。
      * Priority：获取或设置⼀个值，该值指示线程的调度优先级。
      * ThreadState：获取⼀个值，该值包含当前线程的状态。
    * ⽅法:
      * public void Abort()
        在调⽤此⽅法的线程上引发 ThreadAbortException，以开始终⽌此线程的过程。调⽤此⽅法通常会终⽌
        线程。
      * `public static void ResetAbort()`;
        取消为当前线程请求的 Abort。
      * public void Start()
        开始⼀个线程。
      * `public static void Sleep( int millisecondsTimeout )`
        让线程暂停⼀段时间。
      * `public static bool Yield()`
        导致调⽤线程执⾏准备好在当前处理器上运⾏的另⼀个线程。由操作系统选择要执⾏的线程。
## .NET/C#⾯试题汇总系列：ASP.NET MVC
1. MVC中的TempData\ViewBag\ViewData区别?
   * TempData  保存在Session中，Controller每次执⾏请求的时候，会从Session中先获取 TempData，⽽
   后清除Session，获取完TempData数据，虽然保存在内部字典对象中，但是其集合中的每个条⽬访问⼀次
   后就从字典表中删 除，ViewData存的是Key/Value字典，使⽤时需要类型转换。
   * ViewBag和ViewData只在当前Action中有效，等同于View，ViewBag⽐ViewData慢，ViewBag存
   dynamic类型数据，使⽤时不需要类型转换
   * ViewData和ViewBag 中的值可以互相访问，因为ViewBag的实现中包含了ViewData，ViewData存的是
   Key/Value字典，使⽤时需要类型转换
2. 阐述下MVC框架的机制，各个模块的作⽤?
   * 所谓模型，就是MVC需要提供的数据源，负责数据的访问和维护。
   * 所谓视图，就是⽤于显示模型中数据的⽤户界⾯。
   * 所谓控制器，就是⽤来处理⽤户的输⼊，负责改变模型的状态并选择适当的视图来显示模型的数据。
3. ASP.NET和ASP.NET MVC的关系?
   * ASP.NET MVC是在核⼼ASP.NET基础之上构建的，从mvc命名空间System.Web.Mvc就能看出，因为
   System.Web是Asp.NET的核⼼命名空间。
   * ⽐如ASP.NET MVC依赖于HttpHandler，关于请求是怎么进⼊控制器的，其实就是⽤到了HttpHandler
   * Session、Cookie、Cache和Application这些ASP.NET的对象保存机制在MVC中依然是需要⽤到的
   * HttpContext、Request、Response、Server对象在MVC中仍然可以使⽤，在Controller中通过智能感知
   的形式很容易得到这些对象
4. MVC对ASP.NET好处在哪⾥？
   * 提供⾮常清晰的成绩管理，像ui层，也就是view, 数据层model和管理层controller。
   * 单元测试⽐较容易。
   * 改善了数据模型和视图的重⽤性。
   * 代码的结构更加优化。
5. 什么是razor view engine?
   * 这个引擎提供了数据绑定的显示模板。
   ```C#
    @model MvcStore.Models.Customer

    @{ViewBag.Title="Get Customers";}

    <div class="cust"><h3><em>@Model.CustomerName</em></h3></div>
   ```
6. view bag 和 view data之间的区别是什么?
   * view bag是view data的⼀个扩展。扩展以后可以创建动态的属性。这样的好处有:
     * 不需要进⾏类型的转换。
     * 我们可以使⽤dynamic关键字。
     * 但是有⼀个缺点就是view bag要⽐view data慢⼀些。
7. 解释⼀下sections?
   * Sections是html⻚⾯的⼀部分。`@rendersection("testsection")`
   * 在⼦⻚⾯中我们定义如下的sections。`@section testsection {<h1>test content</h1>}`
   * 如果这个section没有定义的话会出错，我们可以使⽤⼀个required属性来防⽌⻚⾯出错。`@rendersection("testsection", required: false)`
8. 为什么要使⽤html.partial?
   * 这个⽅法⽤来显示html string指定的某块视图。`html.partial("testpartialview")`
9. 什么是partial view？
   * Partial view相当于传统⽹⻚表格中的user controls.
   * 它的主要⽬的是为了重复使⽤这些视图，他们⼀般被放在⼀个共享⽂件夹⾥⾯`html.partial()/ html.renderpartial()`
10. MVC同时适⽤于Windows应⽤和Web应⽤吗?
    * 相⽐Windows应⽤，MVC架构更适⽤于Web应⽤。对于Windows应⽤，MVP(Model View Presenter )
    架构更好⼀点。如果你使⽤WPF和Silverlight，MVVM更适合。
11. 在MVC中如何保持Sessions?
    * 可以通过三种⽅式保持： tempdata, viewdata, 和viewbag。
12. 已经有了ASPX，为什么还要Razor?
    * 相⽐ASPX，Razor是⼀个⼲净的、轻量级的和语法更简单。例如，ASPX去显示时间：
    `<%=DateTime.Now%>`
    * 在Razor中，只需要⼀⾏：
    `@DateTime.Now`
13. 在MVC中如何去执⾏Windows认证？
    * 你需要修改web.config⽂件，并设置验证模式为Windows。
    ```java
    <authentication mode="Windows"/>
     <authorization>
     <deny users="?"/>
     </authorization>
    ```
    * 然后在controlle或action中，你可以使⽤ Authorize 属性，指定哪个⽤户可以访问这个controller或
    action。下⾯的代码设置到只有指定的⽤户可以访问它。
    ```C#
    [Authorize(Users= @"WIN-3LI600MWLQN\Administrator")]
    public class StartController : Controller
    {
        //
        // GET: /Start/
        [Authorize(Users = @"WIN-3LI600MWLQN\Administrator")]
        public ActionResult Index()
        {
           return View("MyView");
        }
    }
    ```