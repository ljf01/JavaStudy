# Java SE
### JAVA关键术语
* 简单性
* 面向对象
* 分布式
* 健壮性(早期问题检测、后期动态的(运行时)检测)
* 安全性(适用于网络/分布式环境)
* 体系结构中立(编辑器生成一个体系结构中立的目标文件格式)
* 可移植性
* 解释型
* 高性能
* 多线程
* 动态性
### Java的基础数据类型：
* 整型：
  * int 4字节  -2147483648 ~ 2147483647（正好超过20亿）
  * short 2字节 -32768~32767
  * long  8字节 -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 
  * byte 1字节  -128 ~ 127
  * 注：长整型数值后缀L或l，十六进制的数值有一个前缀0x或0X，八进制有一个前缀0，二进制数值前缀0b或0B
* 浮点类型
    * float 4字节 大约±3.402 823 47E+38F(有效位数为6 ~ 7位)
    * double 8字节 大约±1.797 693 134 862 315 70E+308(有效位数为15位)
    * 注：float类型的数值后面有一个后缀F或f，没有后缀F的浮点数值默认为double类型；也可以在浮点数值后面添加后缀D或d代表double类型；浮点数值的计算都遵循IEEE754规范；
    * 溢出和出错情况：正无穷大、负无穷大、NaN(不是一个数字）
    * 所有非数值的值都认为是不相同的，可以使用Double.isNaN方法；
* char类型
    * 表示单个字符——char类型的数值可以表示为十六进制值，其范围从\u0000到\uffff;
    * Unicode和char类型
* boolean类型
### 变量
* 如果想要知道哪些Unicode字符属于Java中的字母，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查；
* 不可以使用Java保留字作为变量名；
* 同一行可以声明多个变量；
* 声明一个变量之后，必须使用赋值语句对变量进行显示初始化；
### 常量
* 在Java中，使用final关键字指示常量；
* 一般，常量的命名全大写；
* 某个常量可以在类中的多个方法使用，可以将常量定义为类常量；使用static final设置一个类常量；
### 运算符
* +、-、*、/、%
* 数学函数Math类
* 数据类型的转换：强制转换：低精度转为高精度无损失，高精度转为低精度会有损失；
* 浮点数进行舍入运算用Math.round方法；
### 字符串
* 子串:string.substring(0,3);从0位置开始提取到3位置之前的字符,不包含位置3的字符；
* 子串:string.substring(0);提取0位置之后的所有字符;
* 拼接:string temp = "a" + "b";
* 修改字符串:temp = temp.substring(0,3) + 'p!';
* 检测字符串是否相等:String.equals(String1);检测相等且不区分大小写:string.equalslgnoreCase(string1);
* String == String1 只能确定两个字符串是否放置在同一个位置上;
* 空串""是长度未0的字符串，String变量存放null时，代表没有任何对象与该变量关联;
* Java字符串由char值序列组成;
* String的常规用法:
  * charAt(int index);返回给定位置的代码单元;
  * codePointAt(int index);返回从给定位置开始的码点;
  * offsetByCodePoints(int startIndex,int cpCount);返回从startIndex代码点开始，位移cpCount后的码点索引;
  * compareTo(String other);按照字典顺序，如果字符串位于other之前，返回一个负数，如果字符串位于other之后返回一个正数，如果两个字符串相等，返回0;
  * IntStream codePoints();将这个字符串的码点作为一个流返回，调用toArray将它们放在一个数组中;
  * new String(int[] codePoints,int offset,int count);用数组中从offset开始的count个码点构造一个字符串;
  * boolean equals(Object other);如果字符串与other相等，返回true;
  * boolean equalsIgnoreCase (String other)如果字符串与 other 相等 （ 忽略大小写 )返回true;
  * boolean startsWith ( String prefix );
  * boolean endsWith ( String suffix );如果字符串以 suffix 开头或结尾 ， 则返回 true'
  * int indexOf ( String str )
  * int indexOf ( String str , int fromIndex )
  * int indexOf ( int cp )
  * int indexOf ( int cp , int fromIndex);返回与字符串 str 或代码点 cp 匹配的第一个子串的开始位置 这个位置从索引
  0 或 fromIndex 开始计算 。 如果在原始串中不存在 str ，返回 - 1;
  * int lastIndexOf ( String str );
  * Int lastIndexOf ( String str , int fromIndex );
  * int lastIndexOf ( int cp );
  * int lastIndexOf ( int cp , int fromIndex );返回与字符串 str 或代码点 cp 匹配的最后一个子串的开始位置 。 这个位置从原始串尾
    端或 fromIndex 开始计算;
  * int length ( );返回字符串的长度;
  * int codePointCount ( int startIndex , int endIndex );返回 startIndex 和 endIndex - 1 之间的代码点数量 ,没有配成对的代用字符将计入代码点 
  * String replace ( CharSequence oldString , CharSequence newString )返回一个新字符串,这个字符串用 newString,代替原始字符串中所有的 oldString，可以用 String 或 StringBuilder 对象作为 CharSequence 参数
  * String substring ( int beginIndex )
  * String substring ( int beginIndex , int endIndex );返回一个新字符串,这个字符串包含原始字符串中从beginIndex 到串尾或 endIndex - 1 的所有代码单元;
  * String toLowerCase ( );
  * String toUpperCase ( );返回一个新字符串.这个字符串将原始字符串中的大写字母改为小写 ， 或者将原始字
    符串中的所有小写字母改成了大写字母;
  * String trim ( );返回一个新字符串.这个字符串将删除了原始字符串头部和尾部的空格 
  * String join ( CharSequence delimiter,CharSequence . .. elements );返回一个新字符串,用给定的定界符连接所有元素;
  * 构建字符串:StringBuilder builder = new StringBuilder();使用append方法;使用toString方法返回一个字符串;该类的前身是StringBuffer(线程安全，效率较低);
  * StringBuilder ();构造一个空的字符串构建器;
  * int length ( )返回构建器或缓冲器中的代码单元数量;
  * StringBuilder append (String str)追加一个字符串并返回 this 
  * StringBuilder append ( char c )追加一个代码单元并返回 this 
  * StringBuilder appendCodePoint ( int cp )追加一个代码点并将其转换为一个或两个代码单元并返回 this 。 
  * void setCharAt ( int i , char c )将第 i 个代码单元设置为 c 
  * StringBuilder insert ( int offset , String str )在 offset 位置插入一个字符串并返回 this 
  * StringBuilder insert ( int offset , Char c )在 offset 位置插入一个代码单元并返回 this 
  * StringBuilder delete ( 1 nt startIndex , int endIndex )删除偏移量从 startIndex 到 - endIndex - 1 的代码单元并返回 this 
  * String toString ( )返回一个与构建器或缓冲器内容相同的字符串;
### 输入输出
* 读取输入:Scanner in = new Scanner(System.in);
  String name = in.nextLine();//nextLine方法是因为输入行中可能包含空格;
* 读取一个单词:String firstName = in.next();
* 读取整数:in.nextInt();
* 读取浮点数:in.nextDouble();
* 验证输入是否还有其他单词:hasNext();
* haseNextInt();haseNextDouble();
* Scanner需要导入包:import java.util.*;
* Scanner类不适用于从控制台读取密码,Java SE 6引入了Console类实现这个目的,读取密码代码实现:
* Console cons = System.console();
* String username = cons.readLine("Username:");
* char[] password = cons.readPassword("Password:");
* 格式化输出:System.out.printf("Hello,%s,Next year,you'll be %d",name,age);
  * d十进制整数，
  * x十六进制整数，
  * o八进制整数，
  * f定点浮点数，
  * e指数浮点数，
  * g通用浮点数，
  * a十六进制浮点数，
  * s字符串，
  * c字符，
  * b布尔，
  * h散列码，
  * tx或Tx日期时间，已过时，T强制大写，
  * %百分号，
  * n平台有关的行分隔符;
  * 用户printf的标志:
    * +:打印正数和负数的符号;
    * 空格:在正数之前添加空格;
    * 0:数字前面补0;
    * -:左对齐;
    * (:将负数括在括号内;
    * ,:添加分组分隔符;
    * '#':(对于f格式):包含小数点;
    * '#':(对于x或 0 格式):添加前缀0x或0;
    * $:给定被格式化的参数索引。例如，%1$d,%1$x将以十进制和十六进制打印第一个参数;
    * < : 格式化前面说明的数值。例如%d%<x以十进制和十六进制打印同一个数值;
  * 日期和时间格式转换符:System.out.printf("%tc",new Date());
    * c 完整的日期和时间 Mon Feb 09 18:05:19 PST 2015
    * F ISO 8601日期  2015-05-09
    * D 美国格式的日期   (月/日/年)02/09/2015
    * T 24小时时间  18:05:19
    * ......
  * 文件输入和输出:使用File对象构造一个Scanner对象
    * Scanner in new Scanner(Paths.get("myFile.txt"),"UTF-8");(UTF-8的字符编码，并不一定使用全部，在读取之前需要知道文件的编码格式);
    * 如果想写入文件，需要构造一个PrintWriter对象，PrintWriter out = new PrintWriter("myFile.txt","UTF-8"");
    * 如果文件不存在，则创建该文件，
    * 如果文件名中包括反斜杠符号，则每个反斜杠之前再加一个额外的反斜杠;
  * Scanner、PrintWriter常用操作:
    * Scanner(File f)构造一个从给定文件读取数据的Scanner;
    * Scanner(String data)构造一个从给定字符串读取数据的Scanner
    * PrintWriter(String fileName)构造一个将数据写入文件的PrintWriter,pr.print("");
    * static Path get(String pathname)根据给定的路径名构造一个Path;
### 控制流程:
  * 块(block)作用域:确定了变量的作用域。不能在嵌套的块内申明相同的变量;
  * 条件语句if{}else{}
  * 循环语句while(){};do{}while();for(){};
  * 多重选择:switch(){case:break;default:break;}
  * 中断控制流程语句:break终止循环,continue跳出本次循环;
### 大数值:
  * 基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的两个很有用的类:BigInteger(任意精度的整数运算)和BigDecimal(任意精度的浮点数运算);
  * 大数值的常用计算方式:
  * BigInteger:
    * BigInteger add ( BigInteger other );
    * BigInteger subtract ( BigInteger other );
    * BigInteger multiply ( Biginteger other);
    * BigInteger divide ( BigInteger other );
    * BigInteger mod ( BigInteger other );
    * 返回这个大整数和另一个大整数的和、差、积、商以及余数;
    * int compareTo ( BigInteger other );如果这个大整数与另一个大整数 other 相等 ， 返回 0 ; 如果这个大整数小于另一个大整
      数 other , 返回负数;否则,返回正数;
    * static BigInteger valueOf( long x )返回值等于x的大整数。
  * BigDecimal:
    * BigDecimal add ( BigDecimal other );
    * BigDecimal subtract ( BigDecimal other );
    * BigDecimal multiply ( BigDecimal other);
    * BigDecimal divide ( BigDecimal other );
    * 返回这个大实数和另一个大实数的和、差、积、商;
    * int compareTo ( BigDecimal other );如果这个大整数与另一个大整数 other 相等 ， 返回 0 ; 如果这个大整数小于另一个大整
      数 other , 返回负数;否则,返回正数;
    * static BigDecimal valueOf( long x )返回值等于x的大实数。
    * static BigDecimal valueOf( long x ,int scale)返回值等于x或10(scale比例)的大实数。
  ### 数组:
  * int[] a;
  * int a[];
  * 数据创建就不能改变数据的大小;
  * for each循环
  * for(int age : a){}集合全数据访问的时候建议使用for each循环;
  * 数据初始化以及匿名数组;
  * 数组拷贝:Arrays.copyOf(数组,数组长度);//通常用来扩充数组的长度
  * 命令行参数：Java主程序的main方法都有一个String args[];命令行参数
  * 数组排序:Arrays.sort(数组名);使用了快速排序算法
  * static String toString(type[] a);返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔;
  * static type copyOfRange(type[] a,int start,int end);返回a类型相同的一个数组，其长度位end-start，数组元素为a的值;
  * static int binarySearch(type[] a,type v);
  * static int binarySearch(type[] a,int start,int end,type v)采用二分搜索算法查找值v,如果查找成功则返回相应的下标值，否则，返回一个负数值r,-r-1是为保持a有序v应插入的位置;
  * static void fill(type[] a,type v)将数组的所有数据元素值设置为v;
  * static boolean equals(type[] a,type [] b);如果两个数组大小相同,并且下标相同的元素都对应相等，返回true;
  * 多维数组:double[][]data;int [][] data = {{1,2,3,4},{1,2,3,4}};
  * 多维数组访问:data[i][j];二维数组的遍历需要使用嵌套for循环;
  * 不规则数组:数组的每一行有不同的长度;

## 对象和类
### 面向对象程序设计(OOP)概述
* 类
  * 类是构造对象的模板或蓝图;
  * 封装(encapsulation 有时称为数据隐藏)
* 对象
  * 对象的行为
  * 对象的状态
  * 对象标识
* 识别类
* 类之间的关系
  * 依赖:如果一个类的方法操纵另一个类的对象，就说一个类依赖另一个类;
  * 聚合:类A的对象包含类B的对象;
  * 继承:类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能;
### 使用预定义类
* 对象与对象变量
  * 使用构造器(constructor)构造新实例;
  * 构造器的名字应该与类名相同;
  * 想要构造一个对象，需要在构造器之前加上new操作符;
  * 任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用;
  * 可以显式的将对象变量设置为null，表明这个对象变量目前没有引用任何对象;
  * 如果直接操作变量为null的对象则会产生运行时错误;
  * 局部变量不会自动的初始化为null，而必须通过调用new或将它们设置为null进行初始化;
  * Date类是用来表示时间点;Java类库中的LocalDate类用来表示大家熟悉的日历表示法:
  * 更改器方法GregorianCalendar.add()与访问器方法GregorianCalendar.get();
### 用户自定义类
* Employee类
* 多个源文件的使用:通配符调用Java编辑器:javac Employee*.java;
  * 使用javac EmployeeTest.java编译时，当java的编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件。如果没有找到这个文件
    就会自动搜索Employee.java然后对它进行编译，如果Employee.java版本较已有的Employee.class文件版本新
    java编译器就会自动的重新编译这个文件;
* 类剖析
* 构造器
* 隐式参数与显式参数(有些把隐式参数称为方法调用的目标或接收者)
  * 在每个方法中，关键字this表示隐式参数;
* 封装的优点
  * 改变内部实现，除了该类的方法外，不会影响其他代码;
  * 更改器方法可以执行错误检查，而直接对域进行赋值将不会进行这些处理;
* 基于类的访问权限
  * 方法可以访问所调用对象的私有数据;
* 私有方法
  * 将public改为private
* final实例域
  * 可以将实力域定义为final,构建对象时必须初始化这样的域,也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，
    并且在后面的操作中，不能够再对它进行修改;
  * final修饰符大都应用于基本类型域，或不可变类的域；
  * final关键字，其中所有的方法都不能被重写，不能被继承；
### 静态域与静态方法
* 静态域
  * 如果将域定义为 static , 每个类中只有一个这样的域而每一个对象对于所有的实例域却都有自己的一份拷贝 例如，假定需要给每一个雇员賦予唯一的标识码这里给 Employee类添加一个实例域id和一个静态域 nextId,有1000个Employee类对象就有1000个实力域的ID，但是只有一个静态域nextId;即使没有一个雇员对象，静态域nextId也存在，
    它属于类而不属于任何独立的对象;
* 静态变量 static final
* 静态方法:静态方法是一种不能向对象实施操作的方法;
* 工厂方法：静态方法还有另外一种常见的用途，类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象;
* main方法：main方法不对任何对象进行操作，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象;

### 方法参数
* 方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容;
     